/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * gc_cuckoo_map.h
 *
 *  Created on: Jul 28, 2014
 *      Author: evank
 */

#ifndef GC_CUCKOO_MAP_H_
#define GC_CUCKOO_MAP_H_

#include <cstdint>
#include <random>
#include <atomic>
#include <memory>
#include <utility>
#include <cassert>
#include <random>

#include "mpgc/gc.h"
#include "ruts/bit_field.h"
#include "ruts/meta.h"
#include "ruts/hashes.h"
#include "ruts/cas_loop.h"

namespace mpgc {

  template <std::size_t Cap, std::size_t Bits, std::size_t Size, typename Enable = void> struct __bits_needed;

  template <typename K, typename V, typename Hash1=ruts::hash1<K>, typename Hash2=ruts::hash2<K>,
      std::size_t SegBits = 10>
  class gc_cuckoo_map : public gc_allocated {
  public:
    using key_type = K;
    using value_type = V;

    using hash1_fn_type = Hash1;
    using hash2_fn_type = Hash2;
    using hash_type = uint64_t;

  private:
    struct entry_type : gc_allocated {
      const key_type key;
      std::atomic<value_type> val;
      entry_type (gc_token &gc, const key_type &k, const value_type &v) : gc_allocated{gc}, key{k}, val{v} {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(entry_type)
	  .template WITH_FIELD(&entry_type::key)
	  .template WITH_FIELD(&entry_type::val);
        return d;
      }
    };

    constexpr static std::size_t num_flags = 2;
    using entry_ptr_type = versioned_gc_ptr<entry_type, num_flags>;
    using atomic_entry_ptr_type = atomic_versioned_gc_ptr<entry_type, num_flags>;
    /**
     * Pointer is in the process of being moved from one table to the other.  Not considered there yet.
     * (It may have been deleted between the time we started and the time we wrote.)
     */
    constexpr static typename entry_ptr_type::template flag_id<0> moving{};
    /**
     * Pointer has (maybe) been moved from segment to its replacement and shouldn't be overwritten
     */
    constexpr static typename entry_ptr_type::template flag_id<1> frozen{};


    constexpr static std::size_t n_tables = 2;
    constexpr static std::size_t n_seg_bits = SegBits;
    constexpr static std::size_t max_eviction_depth = 8;
    constexpr static std::size_t default_initial_segment_bits = 10;
    constexpr static std::size_t max_segment_slot_bits = 64-n_seg_bits;
    constexpr static std::size_t default_cap = 1 << (n_seg_bits + default_initial_segment_bits);

    enum class side { LEFT, RIGHT };


    class switched_hash {
      const hash1_fn_type hash1;
      const hash2_fn_type hash2;
      const bool use_hash1;
    public:
      switched_hash(side s, const hash1_fn_type h1, const hash2_fn_type h2) : hash1(h1), hash2(h2), use_hash1(s == side::LEFT) {}
      hash_type operator()(const key_type &key) const {
        return use_hash1 ? hash1(key) : hash2(key);
      }
      static const auto &descriptor() {
	static gc_descriptor d =
	  GC_DESC(switched_hash)
	  .template WITH_FIELD(&switched_hash::hash1)
	  .template WITH_FIELD(&switched_hash::hash2)
	  .template WITH_FIELD(&switched_hash::use_hash1);
	return d;
      }
    };




    struct replace_return {
      bool replaced = false;
      bool had_value = false;
      value_type old_value;
      operator bool() const {
        return replaced;
      }
      replace_return() {}
      replace_return(bool r, bool hv, const value_type &ov)
      : replaced(r),
        had_value(hv),
        old_value(ov)
      {}
    };


    class table;
    class segment;

    struct slot_const_ref {
      gc_ptr<const segment> seg;
      std::size_t index;
      const atomic_entry_ptr_type *slot;
      operator const atomic_entry_ptr_type *() const {
        return slot;
      }
      const atomic_entry_ptr_type *operator->() const {
        return slot;
      }
      entry_ptr_type contents() const {
        return slot->contents();
      }
      slot_const_ref(const gc_ptr<const segment> &s, std::size_t i, const atomic_entry_ptr_type &sr)
      : seg(s), index(i), slot(&sr)
      {}
    };

    struct slot_ref {
      gc_ptr<segment> seg;
      std::size_t index;
      atomic_entry_ptr_type *slot;
      operator atomic_entry_ptr_type *() const {
        return slot;
      }
      atomic_entry_ptr_type *operator->() const {
        return slot;
      }
      operator slot_const_ref() const {
        return slot_const_ref(seg, index, *slot);
      }
      entry_ptr_type contents() const {
        return slot->contents();
      }
      slot_ref(const gc_ptr<segment> &s, std::size_t i, atomic_entry_ptr_type &sr)
      : seg(s), index(i), slot(&sr)
      {}
    };

    class source_grew {};

    class segment : public gc_allocated {
      const std::size_t _num;
      const gc_ptr<table> _table;
      switched_hash _hash = _table->_hash;
      const std::size_t _slot_bits;
      const std::size_t _size = (std::size_t{1} << _slot_bits);
      const std::size_t _mask = _size-1;
      gc_array_ptr<atomic_entry_ptr_type> _slots{_size};
      std::atomic<gc_ptr<segment>> _replacement{nullptr};
      mutable std::atomic<std::size_t> _next_to_migrate{0};

      friend class table;
      friend class gc_cuckoo_map;

      /*constexpr*/ std::size_t slot_index(hash_type hash) const {
        return hash & _mask;
      }

      slot_ref slot(hash_type hash) {
        std::size_t i = slot_index(hash);
        return slot_ref(GC_THIS, i, _slots[i]);
      }
      slot_const_ref slot(hash_type hash) const {
        std::size_t i = slot_index(hash);
        return slot_const_ref(GC_THIS, i, _slots[i]);
      }

      slot_ref slot(const key_type &key) {
        return slot(_hash(key));
      }
      slot_const_ref slot(const key_type &key) const {
        return slot(_hash(key));
      }



      bool matches(const key_type &key, const entry_ptr_type &ep) const
      {
        gc_ptr<entry_type> e = ep.pointer();
        return (e != nullptr && !moving(ep) && e->key == key);
      }

      bool replace_null(const gc_ptr<entry_type> &with, hash_type hash) {
        atomic_entry_ptr_type &s = *slot(hash);

        auto guard = [=](const entry_ptr_type &ep) {
          return ep == nullptr && !ep[frozen];
        };

        auto change = [=](entry_ptr_type ep) {
          return ep.inc_and_set(with);
        };

        auto ur = s.try_update(1, guard, change);
        //  we don't want to succeed if the blocker points to the
        //  same value, because that's indicative of a "locked entry"
        //  due to a process crash immediately following removal of
        //  the "moving" flag.  (At least when evicting)
        if (ur) {
          return true;
        } else if (ur.prior_value[frozen]) {
          gc_ptr<segment> new_seg = help_with_grow();
          return new_seg->replace_null(with, hash);
        } else {
          return false;
        }
      }


      // Throws source_grew if the source is frozen when we do the second read, because this
      // may no longer be the slot we wanted to move from.

      // On successful return, either the source or the destination (or neither) has the value,
      // but not both.

      /*
       * Note that it's possible that both source and target have entries (these should be
       * different unless we're in the middle of a move) with the same key.  In this case,
       * the left shadows the right, and we allow the move from left to right, but not from
       * right to left.  (Strictly speaking, we could go the other way, too, with the right-
       * to-left move not actually moving anything, but this raises the possibility that both
       * moves will happen at the same side and both will clear, deleting both.
       */

      bool accept_move(slot_ref &source,
                       entry_ptr_type current,
                       slot_ref &target)
      {
        if (moving(current)) {
          // we can't move something that's being moved.
          return false;
        }

	if (current.pointer() == nullptr) {
	  // For some reason we're trying to move a null.
	  // We'll just say we did it.
	  return true;
	}

        auto guard = [=](const entry_ptr_type &ep) {
          // TODO: Can we usurp if we see that somebody else is moving it?
	  if (ep[frozen]) {
	    return false;
	  }
	  auto ptr = ep.pointer();
	  if (ptr == nullptr) {
	    return true;
	  }
	  return (ptr->key == current->key 
		  && _table->_side == side::RIGHT);
        };

        auto change = [=](entry_ptr_type ep) {
          ep.pointer() = current.pointer();
          ep[moving] = true;
          ep.version()++;
          return ep;
        };

        auto ur = target->try_update(guard, change);
        if (!ur) {
          // not empty or frozen.
          if (ur.prior_value[frozen]) {
            gc_ptr<segment> new_seg = help_with_grow();
            // Find the new target slot (and communicate it back to the caller)
            target = new_seg->slot(current->key);
            return new_seg->accept_move(source, current, target);
          }
	  /*
	   * If we wanted to allow RTL moves with equivalent keys, we'd check
	   * for key equivalence here and let it fall through.
	   */
          return false;
        }

        // Check to make sure the old value wasn't deleted since we read it.
        entry_ptr_type sp = source.contents();
        // The logic for handling sources that change seeruts very complicated.  For
        // now, we're going to punt, which may result in more work being done than
        // strictly necessary.
        if (sp[frozen]) {
          _table->_map->clear_slot(target, ur.resulting_value(), current->key);
          throw source_grew{};
        }
        if (sp.pointer() != current) {
          // It was removed, so we need to clear the slot.
          _table->_map->clear_slot(target, ur.resulting_value(), current->key);
          return false;
        }
        // Now we remove the "moving" flag.
        while (true) {
          auto ur2 = target->change_using(ur.resulting_value(), [](entry_ptr_type ep){
            ep[moving] = false;
            ep.version()++;
            return ep;
          });
          // If not, the value was removed from the map after we set the moving flag.
          if (ur2) {
            break;
          } else if (ur2.prior_value[frozen]) {
            // The segment grew, so we need to reestablish the target
            gc_ptr<segment> new_seg = help_with_grow();
            target = new_seg->slot(current->key);
          } else {
            return false;
          }
        }
        // We're done moving.  The value is now in both places.
        // Remove it from the source.  If it's not there, it means it was removed.  That's okay.
        _table->_map->clear_slot(source, current, current->key);
        return true;
      }


      void grow(std::size_t by) {
        gc_ptr<segment> new_seg = make_gc<segment>(GC_THIS, by);
        if (!ruts::try_change_value(_replacement, nullptr, new_seg)) {
          // Somebody else got there first.  That's okay.
        }
        help_with_grow();
        // At the end it will be installed.
      }

      gc_ptr<segment> help_with_grow() const {
        gc_ptr<segment> r = _replacement;
        segment *nc_this = const_cast<segment *>(this);
        for (std::size_t i = _next_to_migrate; i < _size; /* update at end */) {
          // We're okay with casting away constness to freeze the slot.
          atomic_entry_ptr_type &slot = nc_this->_slots[i];
          auto ur = slot.template set_flag(frozen);
          // We may not have been the first one to freeze it, but we can't assume that
          // the one who did succeeded in copying it.
          entry_ptr_type ep = ur.new_value;
          gc_ptr<entry_type> e = ep;
          if (e != nullptr) {
            // Find the slot in the replacement.
            hash_type h = _hash(e->key);
            std::size_t i = r->slot_index(h);

            // we want to keep the same version number on the other side, but it needs to
            // not be frozen.  It's okay if it's moving, since we still want to complete the move.

            // TODO: *Why* do we want to keep the same version number
            // on the other side?  What's wrong with simply restarting
            // at one?
            ep[frozen] = false;
            // While everybody who's helping with the move will set
            // the same value, we have to worry about this thread
            // getting delayed for long enough that not only did the
            // value get moved by another thread, but the entire grow
            // finished, and somebody replaced the moved value with
            // something else.  So we can't just unconditionally move.
            // So instead we try to replace the initial null with this
            // value.  If it fails, that means that somebody else did
            // it.
            r->_slots[i].change(nullptr, ep);
          }
	  i = ruts::increment_to_at_least(_next_to_migrate, i+1).resulting_value();
        }
        // Now everything has been moved.  We might be the first to have finished (or the
        // one who was might have died before installing), so we'll try to install.
        ruts::cas_loop_return_value<gc_ptr<segment>>
          install_res = ruts::try_change_value(_table->_segments[_num], this_as_gc_ptr(nc_this), r);
        // If that failed, somebody else got there first... and we might even have grown
        // again.  But that's okay.  We've completed this grow.
        // Even if it succeeded, we can't delete the old one yet, because others are using it.
        // So we'll drop it on the floor for now.  Eventually, we'll probably need to use
        // hazard pointers.
        // In any case, we return the currently-installed segment.
        return install_res.resulting_value();
      }

    public:
      segment(gc_token &gc, std::size_t n, std::size_t slot_bits, const gc_ptr<table> &t)
      : gc_allocated{gc},
        _num(n),
        _table(t),
        _slot_bits(slot_bits)      {
      }

      explicit segment(gc_token &gc, const gc_ptr<segment> &prior, std::size_t plus_bits)
      : segment(gc,
                prior->_num,
                prior->_slot_bits+plus_bits,
                prior->_table)
      {
//        std::cerr << "--- Growing segment " << prior << " (" << prior->_slot_bits << ") "
//            << "into " << this << " (" << _slot_bits << ")." << std::endl;
      }

      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(segment)
	  .template WITH_FIELD(&segment::_num)
	  .template WITH_FIELD(&segment::_table)
	  .template WITH_FIELD(&segment::_hash)
	  .template WITH_FIELD(&segment::_slot_bits)
	  .template WITH_FIELD(&segment::_size)
	  .template WITH_FIELD(&segment::_mask)
	  .template WITH_FIELD(&segment::_slots)
	  .template WITH_FIELD(&segment::_replacement)
	  .template WITH_FIELD(&segment::_next_to_migrate);
        return d;
      }

      gc_ptr<entry_type> find(const key_type &key, hash_type hash) const {
        entry_ptr_type current_entry = slot(hash).contents();
        if (current_entry[frozen]) {
          gc_ptr<segment> new_seg = help_with_grow();
          return new_seg->find(key, hash);
        }
        if (matches(key, current_entry)) {
          return current_entry;
        } else {
          return nullptr;
        }
      }



      bool remove(const key_type &key, hash_type hash) {
        slot_ref s = slot(hash);
	entry_ptr_type ep = s.contents();
	while (1) {
	  if (ep[frozen]) {
	    gc_ptr<segment> new_seg = help_with_grow();
	    return new_seg->remove(key, hash);
	  }
	  gc_ptr<entry_type> e = ep.pointer();
	  if (e == nullptr || e->key != key) {
	    return false;
	  }
	  auto ur = s->change_using(ep, inc_and_clear_value);
	  if (ur) {
	    return true;
	  }
	  /*
	   * Otherwise somebody changed it, possibly just
	   * to remove the moving flag.  So we'll go around
	   * again and check.  If it's not us, we'll notice
	   * next time.
	   */
	  ep = ur.prior_value;
	}
      }


      void growth_candidate(const key_type &key1,
                            const key_type &key2,
                            gc_ptr<segment> &best,
                            std::size_t &resulting_size,
                            std::size_t &growth)
      {
        // If we're already too big, don't bother.
        if (_slot_bits >= resulting_size) {
          return;
        }
        hash_type h1 = _hash(key1);
        hash_type h2 = _hash(key2);
        // We assume they collide in the current _slot_bits
        hash_type x = (h1 ^ h2) >> (_slot_bits+1);
        for (std::size_t b = _slot_bits+1; b <= resulting_size; b++, x >>= 1) {
          if ((x & 1) != 0) {
            // Found a difference and we know we're not too big.  But we may
            // be big enough that growth matters.
            std::size_t g = b-_slot_bits;
            if (b < resulting_size || g > growth) {
              resulting_size = b;
              growth = g;
              best = GC_THIS;
            }
            return;
          }
        }


      }

    };

    class table : public gc_allocated {
      static const std::size_t n_segments = 1 << n_seg_bits;

      const gc_ptr<gc_cuckoo_map> _map;
      const side _side;
      const switched_hash _hash;
      using atomic_seg_ptr = std::atomic<gc_ptr<segment>>;
      const gc_array_ptr<atomic_seg_ptr> _segments = make_gc_array<atomic_seg_ptr>(n_segments);

      gc_ptr<const segment> find_segment(hash_type hash) const {
        std::size_t seg_num = left_bit_field(hash, n_seg_bits);
        gc_ptr<const segment> sp = _segments[seg_num].load();
        return sp;
      }
      gc_ptr<segment> find_segment(hash_type hash) {
        std::size_t seg_num = left_bit_field(hash, n_seg_bits);
        return _segments[seg_num];
      }

      friend class segment;
      friend class gc_cuckoo_map;
    public:

      explicit table(gc_token &gc, const gc_ptr<gc_cuckoo_map> &m, side s, const hash1_fn_type &hash1, const hash2_fn_type hash2, std::size_t seg_slot_bits) :
      gc_allocated{gc}, _map(m), _side(s), _hash(s, hash1, hash2)
      {
        int n = 0;
        for (auto &p : _segments) {
          p = make_gc<segment>(n++, seg_slot_bits, GC_THIS);
        }
      }

      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(table)
	  .template WITH_FIELD(&table::_map)
	  .template WITH_FIELD(&table::_side)
	  .template WITH_FIELD(&table::_hash)
	  .template WITH_FIELD(&table::_segments);
        return d;
      }

      gc_ptr<table> other_side() const {
        return _map->other_table(_side);
      }

      slot_ref slot(const key_type &key) {
        hash_type hash = _hash(key);
        gc_ptr<segment> seg = find_segment(hash);
        return seg->slot(hash);
      }

      gc_ptr<entry_type> find(const key_type &key) const {
        hash_type hash = _hash(key);
        gc_ptr<const segment> seg = find_segment(hash);
        return seg->find(key, hash);
      }

      bool remove(const key_type &key) {
        hash_type hash = _hash(key);
        gc_ptr<segment> seg = find_segment(hash);
        return seg->remove(key, hash);
      }
      bool replace_null(const gc_ptr<entry_type> &with) {
        hash_type hash = _hash(with->key);
        gc_ptr<segment> seg = find_segment(hash);
        return seg->replace_null(with, hash);
      }
    };

    gc_ptr<table> _left_table;
    gc_ptr<table> _right_table;

    gc_ptr<table> table_on(side s) {
      return s == side::LEFT ? _left_table : _right_table;
    }

    gc_ptr<table> other_table(side s) {
      return s == side::RIGHT ? _left_table : _right_table;
    }

    gc_ptr<entry_type> find(const key_type &key) const {
      gc_ptr<entry_type> e = _left_table->find(key);
      if (e == nullptr) {
        e = _right_table->find(key);
      }
      return e;
    }



    class grow_needed {};

    // Propagates source_grew if it gets one from an accept_move() call
    side
    evict_one(slot_ref &left_source, slot_ref &right_source,
              std::size_t depth, std::size_t max_depth)
    {
      if (depth > max_depth) {
        throw grow_needed{};
      }

      while (1) {
        // we loop until we succeed in moving or until we get told it's impossible

        entry_ptr_type left_current = left_source.contents();
        if (left_current == nullptr && !left_current[frozen]) {
          // there's no point in moving nothing.
          return side::LEFT;
        }
        entry_ptr_type right_current = right_source.contents();
        if (right_current == nullptr &&!right_current[frozen]) {
          // there's no point in moving nothing.
          return side::RIGHT;
        }
        if (left_current[frozen]) {
          throw source_grew{};
        }
        if (right_current[frozen]) {
          throw source_grew{};
        }

        slot_ref left_target = _right_table->slot(left_current->key);
        if (left_target.seg->accept_move(left_source, left_current, left_target)) {
          return side::LEFT;
        }
        slot_ref right_target = _left_table->slot(right_current->key);
        if (right_target.seg->accept_move(right_source, right_current, right_target)) {
          return side::RIGHT;
        }

        // TODO: If one of our targets (the move's sources grew, we need to figure out a new target
        // and retry.  But if our source would have wound up in the same slot in the old and new segments,
        // it's okay
        side rec_call;
        try {
          // This may throw a grow_needed.  We pass it through.
          rec_call = evict_one(right_target, left_target, depth+1, max_depth);
        } catch (source_grew& ex) {
          continue;
        }
        switch (rec_call) {
        case side::LEFT:
          // we cleared out the one on the left, so we try to move the right source
          if (right_target.seg->accept_move(right_source, (right_current = right_source.contents()),
                                            right_target))
          {
            return side::RIGHT;
          }
          break;
        case side::RIGHT:
          // we cleared out the one on the right, so we try to move the left source
          if (left_target.seg->accept_move(left_source, (left_current = left_source.contents()),
                                           left_target))
          {
            return side::LEFT;
          }
          break;
        }
      }
      assert(ruts::fail("infinite loop ended"));
      throw grow_needed{};
    }


    void best_to_grow(gc_ptr<table> t,
                      key_type key,
                      gc_ptr<segment> &best,
                      std::size_t &resulting_size,
                      std::size_t &growth)
    {
      for (std::size_t d = 0; d < max_eviction_depth; d++) {
        slot_ref slot = t->slot(key);
        gc_ptr<entry_type> e = slot.contents();
        if (e == nullptr) {
          // There's an open slot.  No point in continuing.
          best = nullptr;
          return;
        }
        slot.seg->growth_candidate(key, e->key, best, resulting_size, growth);
        key = e->key;
        t = t->other_side();
      }

    }


    std::pair<gc_ptr<segment>, std::size_t>
    best_to_grow(const key_type &key) {
      gc_ptr<segment> best = nullptr;
      std::size_t resulting_size = 65;
      std::size_t growth = 0;
      best_to_grow(_left_table, key, best, resulting_size, growth);
      if (best != nullptr) {
        best_to_grow(_right_table, key, best, resulting_size, growth);
      }
      return std::make_pair(best, growth);
    }

  static entry_ptr_type inc_and_clear_value(entry_ptr_type e) {
    e.pointer() = nullptr;
    e.version()++;
    e[moving] = false;
    return e;
  }

    bool clear_slot(const slot_ref &slot, entry_ptr_type expected, const key_type &key){
      auto ur = slot->change_using(expected, inc_and_clear_value);
      if (ur) {
        return true;
      } else {
        if (ur.prior_value[frozen]) {
          // The slot started growing after we obtained it.  Help it finish and
          // find a new segment.  (It must have the same segment number.)
          gc_ptr<segment> new_seg = slot.seg->help_with_grow();
          slot_ref new_slot = new_seg->slot(key);
          return clear_slot(new_slot, expected, key);
        }
        gc_ptr<entry_type> pvp = ur.prior_value.pointer();
        // If it's null, that means that somebody else must've removed it (or moved it),
        // but the slot's clear anyway.
        return pvp == nullptr;
      }
    }

    void evict_blocker(const key_type &key) {
      while (true) {
        slot_ref left_slot = _left_table->slot(key);
        slot_ref right_slot = _right_table->slot(key);
        try {
          evict_one(left_slot, right_slot, 0, max_eviction_depth);
          return;
        } catch (source_grew &) {
          continue;
        } catch (grow_needed &) {
          std::pair<gc_ptr<segment> , std::size_t> to_grow = best_to_grow(key);
          if (to_grow.first == nullptr) {
            // If it's null, that means we found a null along the way...Or nothing can be grown,
            // which we assume can't happen.
            continue;
          }
          to_grow.first->grow(to_grow.second);
          return;
        }
      }
    }

    bool put_in_existing(const key_type &key, const value_type &val, bool allow_replacep, replace_return &rr) {
      gc_ptr<entry_type> e = find(key);
      if (e == nullptr) {
        return false;
      } else {
        rr.had_value = true;
        rr.old_value = e->val;
        if (!allow_replacep) {
          rr.replaced = false;
        } else {
          // if this is no longer there by the time we return, that's
          // okay.  It's as if we did the set just before another thread
          // did the remove.
          e->val = val;
          rr.replaced = true;
        }
        return true;
      }
    }

    void evict_and_put(const gc_ptr<entry_type> &e, bool allow_replacep, replace_return &rr) {
      // This should eventually succeed.  (Most of the time, the first or second time around)
      while (true) {
        if (_left_table->replace_null(e)) {
          rr = replace_return(true, false, value_type());
          return;
        }
        // It's possible that somebody else put an entry for the same key
        // in the left table since the last time we looked.  This is okay.  It's as
        // if we wrote first and they overwrote.
        if (_right_table->replace_null(e)) {
          rr = replace_return(true, false, value_type());
          return;
        }
        evict_blocker(e->key);
        if (put_in_existing(e->key, e->val, allow_replacep, rr)) {
          return;
        }
      }

    }

    void put(const key_type &key, const value_type &val, bool allow_replacep, replace_return &rr) {
      if (!put_in_existing(key, val, allow_replacep, rr)) {
        gc_ptr<entry_type> e = make_gc<entry_type>(key, val);
        evict_and_put(e, allow_replacep, rr);
      }
    }

    static std::size_t slot_bits_for(std::size_t cap) {
      std::size_t bits = 1;
      std::size_t size = 1<<(n_seg_bits+1);
      while (size < cap) {
        bits++;
        size <<=1;
      }
      return bits;
    }

  public:
    gc_cuckoo_map(gc_token &gc, const hash1_fn_type &h1, const hash2_fn_type &h2, std::size_t capacity = default_cap) :
      gc_allocated{gc},
      _left_table{make_gc<table>(GC_THIS, side::LEFT, h1, h2, slot_bits_for(capacity))},
      _right_table{make_gc<table>(GC_THIS, side::RIGHT, h1, h2, slot_bits_for(capacity))}
      {}

    explicit gc_cuckoo_map(gc_token &gc, std::size_t capacity = default_cap) :
        gc_cuckoo_map(gc, hash1_fn_type{}, hash2_fn_type{}, capacity)
    {}

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_cuckoo_map)
	.template WITH_FIELD(&gc_cuckoo_map::_left_table)
	.template WITH_FIELD(&gc_cuckoo_map::_right_table);
      return d;
    }

    bool contains(const key_type &key) const {
      return find(key) != nullptr;
    }

    value_type get(const key_type &key) const {
      gc_ptr<entry_type> e = find(key);
      return e == nullptr ? value_type{} : static_cast<value_type>(e->val);
    }

    bool remove(const key_type &key) {
      // need to go in reverse order just in case the two tables both
      // temporarily hold values (left shadowing right) with different
      // entries.  Removing the shadowing one first would make the other
      // value reappear.
      bool res2 = _right_table->remove(key);
      bool res1 = _left_table->remove(key);
      return res1 || res2;
    }



    replace_return put(const key_type &key, const value_type &val) {
      replace_return rr;
      put(key, val, true, rr);
      return rr;
    }

    replace_return put_new(const key_type &key, const value_type &val) {
      replace_return rr;
      put(key, val, false, rr);
      return rr;
    }

    replace_return replace(const key_type &key,
                           const value_type &expected,
                           const value_type &val) {
      gc_ptr<entry_type> e = find(key);
      if (e == nullptr) {
        // if it's not there, we can't replace
        return replace_return(false, false, value_type {});
      }
      auto clrv = ruts::try_change_value(e->val, expected, val);
      return replace_return(clrv, true, clrv.prior_value);
    }

    class reference {
      gc_ptr<gc_cuckoo_map> _map;
      const key_type _key;
    public:
      reference(const gc_ptr<gc_cuckoo_map> &m, const key_type key) : _map(m), _key(key) {}
      bool exists() const {
        return _map->contains(_key);
      }
      operator value_type() const {
        return _map->get(_key);
      }
      reference &operator=(const value_type & val) {
        _map->put(_key, val);
        return *this;
      }
    };

    std::pair<bool, value_type> lookup(const key_type &key) {
      gc_ptr<entry_type> e = find(key);
      if (e == nullptr) {
        return std::make_pair(false, value_type());
      } else {
        return std::make_pair(true, e->val.load());
      }
    }

    reference operator[](const key_type &key) {
      return reference(GC_THIS, key);
    }

    value_type operator[](const key_type &key) const {
      return get(key);
    }

  };

  template <typename K, typename V, typename Hash1=ruts::hash1<K>, typename Hash2=ruts::hash2<K> >
  using small_gc_cuckoo_map = gc_cuckoo_map<K,V,Hash1,Hash2,0>;


  template <typename K, typename V, typename Hash1, typename Hash2, std::size_t SegBits>
  constexpr typename gc_cuckoo_map<K,V,Hash1,Hash2,SegBits>::entry_ptr_type::template flag_id<0>
  gc_cuckoo_map<K,V,Hash1,Hash2,SegBits>::moving;

  template <typename K, typename V, typename Hash1, typename Hash2, std::size_t SegBits>
  constexpr typename gc_cuckoo_map<K,V,Hash1,Hash2,SegBits>::entry_ptr_type::template flag_id<1>
  gc_cuckoo_map<K,V,Hash1,Hash2,SegBits>::frozen;


}



#endif /* GC_CUCKOO_MAP_H_ */
