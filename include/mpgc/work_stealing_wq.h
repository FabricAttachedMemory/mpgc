/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * work_stealing_wq.h
 *
 *  Created on: Aug 7, 2016
 *      Author: gidra
 */

#ifndef GC_WORK_STEALING_WQ_H
#define GC_WORK_STEALING_WQ_H

#include "ruts/lock_free_stack.h"
#include "mark_buffer.h"

namespace mpgc {

  template<typename T>
  class work_stealing_wq {
    static constexpr int32_t buffer_size = mark_buffer<T>::buffer_size;
    using buffer = typename mark_buffer<T>::buffer;

    ruts::lf_stack<buffer, ruts::managed_space::allocator<buffer>> _stack;
    buffer *_front;
    buffer *_back;

   public:

    work_stealing_wq() : _stack(), _front(nullptr), _back(nullptr) {}
    ~work_stealing_wq() {
      _stack.clear();
      if (_front) {
        _stack.deallocate(_front);
      }
      if (_back) {
        _stack.deallocate(_back);
      }
    }

    bool empty() {
      if (_front || _back) {
        return false;
      } else {
        _stack.pop(_back);
        return !_back;
      } 
    }

    /* TODO: There is a fault-tolerance issue here. If the process
     * crashes after pushing a full local buffer, but before erasing
     * the pointer to it, the buffer may get accessed after it is
     * deallocated by a stealing process. To deal with it, we can
     * mantain a free list, so that only the owner deallocates
     * buffers, or reuses them.
     */
    void push(const T &p) {
      if (_back && _back->write_idx == buffer_size) {
        if (!_front) {
          _front = _stack.allocate();
        }
        assert(_front->write_idx < buffer_size);
        _front->buf[_front->write_idx] = p;
        _front->write_idx++;

        if (_front->write_idx == buffer_size) {
          _stack.push(_back);
          _back = _front;
          _front = nullptr;
        }
      } else {
        if (!_back) {
          assert(!_front);
          _back = _stack.allocate();
        } 
        _back->buf[_back->write_idx] = p;
        _back->write_idx++;
      }
    }

    /* For both pop() and front(), it is necessary that
     * it is ensured that the queue is not empty. That is
     * empty() function ensures that we have something to
     * refer via front() and/or pop().
     */
    void pop() {
      assert(_front || _back);
      if (_front && _front->write_idx > 0) {
        _front->write_idx--;
        if (_front->write_idx == 0) {
          _stack.deallocate(_front);
          _front = nullptr;
        }
      } else {
        assert(!_front && _back->write_idx > 0);
        _back->write_idx--;
        if (_back->write_idx == 0) {
          _stack.deallocate(_back);
          _back = nullptr;
        }
      }
    }

    T& front() const {
      assert(_front || _back);
      if (_front) {
        assert(_front->write_idx > 0);
        return _front->buf[_front->write_idx - 1];
      } else {
        assert(_back->write_idx > 0);
        return _back->buf[_back->write_idx - 1];
      }
    }

    bool steal(work_stealing_wq &other) {
      assert(other.empty());
      _stack.pop(other._back);
      return other._back != nullptr;
    }

    /*
     * TODO: Ideally we should deallocate the local chunks
     * that we take over. However, we cannot to avoid double
     * free. The best solution is to start using GC heap for
     * GC data structures too. At the moment we leak memory.
     */
     
    void takeover_locals(work_stealing_wq &other) {
      if (other._front) {
        for (int32_t i = 0; i < other._front->write_idx; i++) {
          push(other._front->buf[i]);
        }
        //other._stack.deallocate(other._front);
        other._front = nullptr;
      }
      if (other._back) {
        for (int32_t i = 0; i < other._back->write_idx; i++) {
          push(other._back->buf[i]);
        }
        //other._stack.deallocate(other._back);
        other._back = nullptr;
      }
    }
  };
}
#endif /*GC_WORK_STEALING_WQ_H*/
