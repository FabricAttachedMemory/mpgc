/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * pheap.h
 *
 *  Created on: Sep 20, 2013
 *      Author: evank
 */

#ifndef PHEAP_H_
#define PHEAP_H_

#include <cstddef>
#include <cstdint>
#include <atomic>
#include <string>
#include <type_traits>
#include <thread>
#include "pheap/pheap_barrier.h"

namespace pheap {
	using std::size_t;

	class in_heap_header;
	class barrier;

	void *in_heap_allocate(in_heap_header *header, barrier &, size_t sz);
	void in_heap_deallocate(in_heap_header *header, barrier &, void *ptr);

	template <class T>
	class in_heap_allocator {
	public:
		using size_type = size_t;
		using difference_type = ptrdiff_t;
		using pointer = T*;
		using const_pointer = const T*;
		using reference = T&;
		using const_reference = const T&;
		using value_type = T;
		template <typename T2> struct rebind
		{
			using other = in_heap_allocator<T2>;
		};
		using propagate_on_container_move_assignment = std::true_type;
		using propagate_on_container_copy_assignment = std::true_type;
		using propagate_on_container_swap = std::true_type;


		explicit in_heap_allocator(in_heap_header *h, barrier &b) throw() : heap(h), _barrier(b) { }
		in_heap_allocator(const in_heap_allocator &other) throw() : heap(other.heap), _barrier(other._barrier) { }
		template<typename T2> in_heap_allocator(const in_heap_allocator<T2>&other) throw() : heap(other.heap), _barrier(other._barrier) { }
		~in_heap_allocator() throw() { }



		pointer allocate(size_type n) {
			return static_cast<T*>(in_heap_allocate(heap, _barrier, n * sizeof(T)));
		}
		void deallocate(pointer ptr, size_type n) {
			in_heap_deallocate(heap, _barrier, ptr);
		}

		template <class U> void destroy(U *ptr) {
			ptr->~U();
		}

		template <class U, class... Args> void construct(U *ptr, Args&&... args) {
			new((void *)ptr) U(std::forward<Args>(args)...);
		}

		in_heap_header *heap;
		barrier &_barrier;
	};




	class persistent_heap {
	public:
		class no_sync_region : public mutate_region {
		public:
			no_sync_region(persistent_heap &heap) : mutate_region(*heap._barrier) {}
		};

		template <typename F> auto no_sync_during(const F &f) -> decltype(f()) {
			no_sync_region r(*this);
			return f();
		}

		void *allocate(size_t n) const {
			return in_heap_allocate(header, *_barrier, n);
		}
		void deallocate(void *ptr) const {
			in_heap_deallocate(header, *_barrier, ptr);
		}
                void deallocate(const void *ptr) const {
                        deallocate(const_cast<void *>(ptr));
                }

		template <class C, class ... Args> C *create(Args&&... args) {
			no_sync_region nsr(*this);
			allocator_type<C> a = allocator<C>();
			C *ptr = a.allocate(1);
			a.construct(ptr, std::forward<Args>(args)...);
			return ptr;
		}

		template <class C> void destroy(C *ptr) {
			no_sync_region nsr(*this);
			allocator_type<C> a = allocator<C>();
			a.destroy(ptr);
			a.deallocate(ptr, 1);
		}
		template <class U, class... Args> U *construct_root(Args&&... args) {
			mutate_region mr(*_barrier);
			U *ptr = create<U>(std::forward<Args>(args)...);
			set_raw_root(ptr);
			return ptr;
		}



		// TODO: If you call sync() from within a no_sync_region, you deadlock!
		void sync();
		persistent_heap(std::string name);
		operator bool() const {
			return header != nullptr;
		}

		template <class T>
		using allocator_type = in_heap_allocator<T>;

		template <class T>
		allocator_type<T> allocator() {
			return allocator_type<T>(header, *_barrier);
		}


		persistent_heap(const persistent_heap &) = delete;
		persistent_heap(persistent_heap &&) = delete;
		persistent_heap &operator =(const persistent_heap &) = delete;
		persistent_heap &operator =(persistent_heap &) = delete;

	private:
		void *get_raw_root() const;
		bool set_raw_root(void *new_root);
		in_heap_header *const header;
		barrier * const _barrier;

		template <class R> friend class persistent_root;
		template <int N> friend class numbered_heap;
	};

	template<typename T1, typename T2>
	inline bool	operator==(const persistent_heap::allocator_type<T1>&a1, const persistent_heap::allocator_type<T2>&a2)
	{ return a1.heap == a2.heap; }

	template<typename T>
	inline bool	operator==(const persistent_heap::allocator_type<T>&a1, const persistent_heap::allocator_type<T>&a2)
	{ return a1.heap == a2.heap; }

	template<typename T1, typename T2>
	inline bool	operator!=(const persistent_heap::allocator_type<T1>&a1, const persistent_heap::allocator_type<T2>&a2)
	{ return a1.heap != a2.heap; }

	template<typename T>
	inline bool	operator!=(const persistent_heap::allocator_type<T>&a1, const persistent_heap::allocator_type<T>&a2)
	{ return a1.heap != a2.heap; }


	template <class R>
	class persistent_root {
	public:
		persistent_root(persistent_heap &h) : heap(h) {}
		operator R *() const {
			return static_cast<R*>(heap.get_raw_root());
		}
		R *operator ->() const {
			return static_cast<R*>(heap.get_raw_root());
		}
		persistent_root &operator =(R *new_root) {
			heap.set_raw_root(new_root);
			return *this;
		}

		template <class... Args> R *construct_new(Args&&... args) {
			return heap.construct_root<R>(std::forward<Args>(args)...);
		}
		void destroy() {
			R *old = *this;
			operator =(nullptr);
			heap.destroy(old);
		}

		friend std::ostream &operator<<(std::ostream &os, const persistent_root &r) {
			return os << *r;
		}

	private:
		persistent_heap &heap;
	};

	template <int N, typename T, typename Enable=void>
	class persistable;

	template <int N, typename T>
	using persistent = typename persistable<N,T>::type;



	template <int N>
	class numbered_heap {
	public:
		static const int number = N;

		template <class T>
		using persistent = pheap::persistent<N,T>;

		class no_sync_region : public persistent_heap::no_sync_region {
		public:
			no_sync_region() : persistent_heap::no_sync_region(inst()) {
				n_no_sync_regions()++;
			}
			~no_sync_region() {
				n_no_sync_regions()--;
			}
		};

		template <typename Fn> static auto no_sync_during(const Fn &f)->decltype(f()) {
			no_sync_region r;
			return f();
		}


		template <class T>
		class allocator_type {
		public:
			using size_type = size_t;
			using difference_type = ptrdiff_t;
			using pointer = T*;
			using const_pointer = const T*;
			using reference = T&;
			using const_reference = const T&;
			using value_type = T;
			template <typename T2> struct rebind
			{
				using other = allocator_type<T2>;
			};
			using propagate_on_container_move_assignment = std::true_type;


			allocator_type () throw() { }
			allocator_type(const allocator_type&) throw() { }
			template<typename T2> allocator_type(const allocator_type<T2>&) throw() { }
			~allocator_type() throw() { }



			pointer allocate(size_type n) {
				return static_cast<T*>(inst().allocate(n * sizeof(T)));
			}
			void deallocate(pointer ptr, size_type n) {
				inst().deallocate(ptr);
			}

			template <class U> void destroy(U *ptr) {
				ptr->~U();
			}

			template <class U, class... Args> void construct(U *ptr, Args&&... args) {
				new((void *)ptr) U(std::forward<Args>(args)...);
			}
		};


		struct deleter {
			template<class T>
			void operator()(T *ptr) {
				ptr->~T();
				inst().deallocate(ptr);
			}
		};

		static persistent_heap &inst() {
			static persistent_heap h(name());
			return h;
		}

		template <class T> static T *ptr_to_root() {
			return static_cast<T*>(inst().get_raw_root());
		}
		template <class T> static T &root_ref() {
			return *ptr_to_root<T>();
		}
		template <class T> static T *set_root(T *new_root) {
			T *old_root = ptr_to_root<T>();
			inst().set_raw_root(new_root);
			return old_root;
		}
		template <class U, class... Args> static U &construct_root(Args&&... args) {
			mutate_region mr(_barrier());
			U *ptr = create<U>(std::forward<Args>(args)...);
			inst().set_raw_root(ptr);
			return *ptr;
		}

		template <class C, class ... Args> static C *create(Args&&... args) {
			no_sync_region nsr;
			allocator_type<C> a;
			C *ptr = a.allocate(1);
			a.construct(ptr, std::forward<Args>(args)...);
			return ptr;
		}

		template <class C> static void destroy(C *ptr) {
			no_sync_region nsr;
			allocator_type<C> a;
			a.destroy(ptr);
			a.deallocate(ptr, 1);
		}

		template <typename T> class root {
		public:
			using heap = numbered_heap<N>;
			operator T&() const {
				return root_ref<T>();
			}
			T &as_ref() const {
				return root_ref<T>();
			}
			T *as_ptr() const {
				return ptr_to_root<T>();
			}
			T* exchange(T *other) {
				return set_root<T>(other);
			}
			root &operator =(T* other) {
				exchange(other);
				return *this;
			}
			bool is_null() const {
				return as_ptr() == nullptr;
			}
			template <class... Args>  T &construct_new(Args&&... args) {
				return construct_root<T>(std::forward<Args>(args)...);
			}
			void destroy() {
				T *old = as_ptr();
				operator =(nullptr);
				heap::destroy(old);
			}

			friend std::ostream &operator<<(std::ostream &os, const root &r) {
				return os << r.as_ref();
			}
		};

		static void sync() {
			assert(n_no_sync_regions() == 0);
			inst().sync();
		}



		static std::string name();
		static uint32_t &n_no_sync_regions() {
			static thread_local uint32_t n = 0;
			return n;
		}

		private:
			static barrier &_barrier() {
				return *inst()._barrier;
			}

	};

	template <int N, typename Root>
	class static_heap : public numbered_heap<N>
	{
	public:
		using numbered = numbered_heap<N>;
		using root_type = persistent<numbered::number,Root>;
		using root = typename numbered::template root<root_type>;

		static root_type &root_ref() {
			return numbered::template root_ref<root_type>();
		}

		static root_type *ptr_to_root() {
			return numbered::template ptr_to_root<root_type>();
		}
		template <class... Args> static root_type &construct_root(Args&&... args) {
			return numbered::template construct_root<root_type>(std::forward<Args>(args)...);
		}

	};

	template <int N, typename T>
	using persistent_allocator = typename numbered_heap<N>::template allocator_type<T>;


	template<int N, typename T1, typename T2>
	inline bool	operator==(const persistent_allocator<N, T1>&, const persistent_allocator<N, T2>&)
	{ return true; }

	template<int N, typename T>
	inline bool	operator==(const persistent_allocator<N, T>&, const persistent_allocator<N, T>&)
	{ return true; }

	template<int N, typename T1, typename T2>
	inline bool	operator!=(const persistent_allocator<N, T1>&, const persistent_allocator<N, T2>&)
	{ return false; }

	template<int N, typename T>
	inline bool operator!=(const persistent_allocator<N,T>&, const persistent_allocator<N,T>&)
	{ return false; }


}

inline void *operator new(size_t sz, const pheap::persistent_heap &heap) {
	return heap.allocate(sz);
}
inline void *operator new[](size_t sz, const pheap::persistent_heap &heap) {
	return heap.allocate(sz);
}

template <int N>
inline void *operator new(size_t sz, pheap::numbered_heap<N> heap) {
	return operator new(sz, pheap::numbered_heap<N>::inst());
}
template <int N>
inline void *operator new[](size_t sz, pheap::numbered_heap<N> heap) {
	return operator new[](sz, pheap::numbered_heap<N>::inst());
}




#endif /* PHEAP_H_ */
