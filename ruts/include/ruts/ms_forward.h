/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * ms_forward.h
 *
 *  Created on: Aug 19, 2014
 *      Author: evank
 */

#ifndef MS_FORWARD_H_
#define MS_FORWARD_H_


#include <atomic>
#include <string>
#include <vector>
#include <memory>
#include <list>
#include <map>
#include <unordered_map>
#include <forward_list>
#include <deque>
#include <set>
#include <unordered_set>
#include <stack>
#include <functional>
#include <utility>
#include <tuple>
#include <type_traits>

#include "ruts/managed.h"
#include <atomic>
#include <type_traits>
/*
#include "ruts/cuckoo_map.h"
*/

namespace ruts {

  template <typename T, typename Enabled = void>
  struct managed_placement_ok {
    template <typename X>
    static typename X::managed_ok check_member(X*);

    static std::false_type check_member(...);
    using type = decltype(check_member((T*)0));
    static constexpr bool value = type::value;
    constexpr operator bool() {
      return value;
    }
  };

  template <typename T>
  constexpr bool is_managed_placement_ok() {
    return std::is_scalar<T>() // arithmetic, enum, pointer, pointer to member, nullptr_t
        || std::is_empty<T>()
        || (managed_placement_ok<T>() && !std::is_polymorphic<T>());
  }


  template <typename T, typename Enabled = void>
  class ms;
  template <typename T> using managed = typename ms<T>::type;

  template <typename T> class unmanaged {};

  template <typename T>
  struct ms<unmanaged<T>>
  {
    using type = T;
  };

  template <typename T>
  struct ms<T, std::enable_if_t<is_managed_placement_ok<T>()>>
  {
    using type = T;
  };


  template <typename CharT, typename Traits, typename Allocator>
  struct ms<std::basic_string<CharT, Traits, Allocator>>
  {
    using type = std::basic_string<CharT, Traits, managed_space::allocator<CharT>>;
  };

  template <typename CharT, typename Traits = std::char_traits<CharT>>
      using ms_basic_string = managed<std::basic_string<CharT,Traits>>;

  using ms_string = ms_basic_string<char>;
  using ms_wstring = ms_basic_string<wchar_t>;
  using ms_u16string = ms_basic_string<char16_t>;
  using ms_u32string = ms_basic_string<char32_t>;

  template <typename T, template <typename ET, typename Alloc> class C>
  struct __ms_allocated
  {
    using elt = managed<T>;
    using type = C<elt, managed_space::allocator<elt>>;
  };

  template <typename T, template <typename ET> class C>
  struct __ms_mapped
  {
    using elt = managed<T>;
    using type = C<elt>;
  };

  template <typename T, typename Allocator>
  struct ms<std::vector<T,Allocator>> : public __ms_allocated<T, std::vector> {};

  template <typename T>
  using ms_vector = managed<std::vector<T>>;

  template <typename T, typename Allocator>
  struct ms<std::list<T,Allocator>> : public __ms_allocated<T, std::list> {};

  template <typename T>
  using ms_list = managed<std::list<T>>;

  template <typename T, typename Allocator>
  struct ms<std::forward_list<T,Allocator>> : public __ms_allocated<T, std::forward_list> {};

  template <typename T>
  using ms_forward_list = managed<std::forward_list<T>>;

  template <typename T, typename Allocator>
  struct ms<std::deque<T,Allocator>> : public __ms_allocated<T, std::deque> {};

  template <typename T>
  using ms_deque = managed<std::deque<T>>;

  template <typename T, typename Container>
  struct ms<std::stack<T,Container>> {
    using elt = managed<T>;
    using cont = managed<Container>;
    using type = std::stack<elt, cont>;
  };

  template <typename T>
  using ms_stack = managed<std::stack<T>>;


  template <typename T>
  struct ms<std::hash<T>> : public __ms_mapped<T, std::hash> {};

  template <typename T>
  struct ms<std::equal_to<T>> : public __ms_mapped<T, std::equal_to> {};

  template <typename T>
  struct ms<std::not_equal_to<T>> : public __ms_mapped<T, std::not_equal_to> {};

  template <typename T>
  struct ms<std::greater<T>> : public __ms_mapped<T, std::greater> {};

  template <typename T>
  struct ms<std::less<T>> : public __ms_mapped<T, std::less> {};

  template <typename T>
  struct ms<std::greater_equal<T>> : public __ms_mapped<T, std::greater_equal> {};

  template <typename T>
  struct ms<std::less_equal<T>> : public __ms_mapped<T, std::less_equal> {};

  template <typename T1, typename T2>
  struct ms<std::pair<T1, T2>>
  {
    using type = std::pair<managed<T1>, managed<T2>>;
  };

  template <typename T1, typename T2>
  using ms_pair = managed<std::pair<T1,T2>>;

  // TODO: How do you do tuples

  template <typename Key, typename Hash, typename KeyEqual, typename Allocator>
  struct ms<std::unordered_set<Key, Hash, KeyEqual, Allocator>, std::enable_if_t<is_managed_placement_ok<Key>()>>
  {
    using type = std::unordered_set<Key, Hash, KeyEqual, managed_space::allocator<Key>>;
  };

  template <typename Key, typename Hash, typename KeyEqual, typename Allocator>
  struct ms<std::unordered_set<Key, Hash, KeyEqual, Allocator>, std::enable_if_t<!is_managed_placement_ok<Key>()>>
  {
    using key = managed<Key>;
    using hash = managed<Hash>;
    using eq = managed<KeyEqual>;
    using type = std::unordered_set<key, hash, eq, managed_space::allocator<key>>;
  };

  template <typename Key, typename Hash = std::hash<Key>, typename KeyEqual = std::equal_to<Key>>
      using ms_unordered_set = managed<std::unordered_set<Key, Hash, KeyEqual>>;

  template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
  struct ms<std::unordered_map<Key, T, Hash, KeyEqual, Allocator>, std::enable_if_t<is_managed_placement_ok<Key>()>>
  {
    using type = std::unordered_map<Key, managed<T>, Hash, KeyEqual, managed_space::allocator<Key>>;
  };

  template <typename Key, typename T, typename Hash, typename KeyEqual, typename Allocator>
  struct ms<std::unordered_map<Key, T, Hash, KeyEqual, Allocator>, std::enable_if_t<!is_managed_placement_ok<Key>()>>
  {
    using key = managed<Key>;
    using val = managed<T>;
    using hash = managed<Hash>;
    using eq = managed<KeyEqual>;
    using type = std::unordered_map<key, val, hash, eq, managed_space::allocator<key>>;
  };


  template <typename Key, typename T, typename Hash = std::hash<Key>, typename KeyEqual = std::equal_to<Key>>
      using ms_unordered_map = std::unordered_map<Key, T, Hash, KeyEqual, managed_space::allocator<std::pair<const Key, T>>>;

  template <typename Key, typename T, typename Compare = std::less<Key>>
      using ms_map = std::map<Key, T, Compare, managed_space::allocator<std::pair<const Key, T>>>;

  template <typename Key, typename Compare = std::less<Key>>
      using ms_set = std::set<Key, Compare, managed_space::allocator<Key>>;


  template <typename T, typename Deleter>
  struct ms<std::unique_ptr<T, Deleter>>
  {
    using elt = managed<T>;
    using type = std::unique_ptr<elt, ruts::managed_space::deleter>;
  };

  template <typename T>
      using ms_unique_ptr = managed<std::unique_ptr<T>>;

/*
 * shared_ptr uses virtual functions to delete, so we can't use it in managed space.
 */
//  template <typename T, typename... Args>
//  std::shared_ptr<managed<T>>
//  ms_make_shared(Args&&... args) {
//    return std::allocate_shared(managed_space::allocator<managed<T>>(), std::forward(args)...);
//  }

#if 0
  template <typename K, typename V, typename Hash1, typename Hash2, std::size_t SegBits, typename Allocator>
  struct ms<ruts::cuckoo_map<K,V,Hash1,Hash2,SegBits,Allocator>>
  {
    using key = managed<K>;
    using val = managed<V>;
    using h1 = managed<Hash1>;
    using h2 = managed<Hash2>;
    using type = ruts::cuckoo_map<key,val,h1,h2,SegBits,managed_space::allocator<val>>;
  };

  template <typename K, typename V,
  typename Hash1 = ruts::hash1<K>, typename Hash2 = ruts::hash2<K>,
      std::size_t SegBits = 10>
      using ms_cuckoo_map = managed<ruts::cuckoo_map<K,V,Hash1,Hash2,SegBits>>;

  template <typename K, typename V, typename Hash1, typename Hash2, typename Allocator>
  struct ms<ruts::small_cuckoo_map<K,V,Hash1,Hash2,Allocator>>
  {
    using key = managed<K>;
    using val = managed<V>;
    using h1 = managed<Hash1>;
    using h2 = managed<Hash2>;
    using type = ruts::small_cuckoo_map<key,val,h1,h2,managed_space::allocator<val>>;
  };

  template <typename K, typename V,
  typename Hash1 = ruts::hash1<K>, typename Hash2 = ruts::hash2<K>>
      using ms_small_cuckoo_map = managed<ruts::small_cuckoo_map<K,V,Hash1,Hash2>>;
#endif
}



#endif /* MS_FORWARD_H_ */
