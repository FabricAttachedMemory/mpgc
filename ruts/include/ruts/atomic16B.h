/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * atomic16B.h
 *
 *  Created on: Jan 11, 2016
 *      Author: gidra
 */

#ifndef ATOMIC16B_H_
#define ATOMIC16B_H_

#include<atomic>

namespace ruts {
#ifdef __aarch64__
  template <typename T>
  class atomic16B {
  protected:
    using contained_type = T;
  private:
    using shadow_type = __uint128_t;

    using atomic_shadow = volatile __uint128_t;

    atomic_shadow _internal;


    static const shadow_type &shadow(const contained_type &p) {
      return reinterpret_cast<const shadow_type &>(p);
    }
    static shadow_type &shadow(contained_type &p) {
      return reinterpret_cast<shadow_type &>(p);
    }
    static contained_type unshadow(const shadow_type &s) {
      return reinterpret_cast<const contained_type &>(s);;
    }

    struct two_double_words_type {
      uint64_t w0;
      uint64_t w1;
    };

    union two_64_to_128_type {
      two_double_words_type two_dw;
      shadow_type qw;
      two_64_to_128_type() : qw(0) {}
      two_64_to_128_type(shadow_type s) : qw(s) {}
      two_64_to_128_type(two_double_words_type t) : two_dw(t) {}
    };

    shadow_type _atomic_load() const {
      two_double_words_type ret;
      uint32_t status;
      asm volatile (
                "1: ldaxp %0, %1, [%3];"
                "   stlxp %w2, %0, %1, [%3];"
                "   cbnz  %w2, 1b;" :
                "=&r" (ret.w0), "=&r" (ret.w1), "=&r" (status) :
                "r" (&_internal) :
                "memory");
      return two_64_to_128_type(ret).qw;
    }

    shadow_type _atomic_exchange(const shadow_type &desired) {
      const two_64_to_128_type& des = static_cast<const two_64_to_128_type&>(desired);
      two_double_words_type ret;
      uint32_t status;
      asm volatile (
                "1: ldaxp %0, %1, [%3];"
                "   stlxp %w2, %4, %5, [%3];"
                "   cbnz  %w2, 1b;" :
                "=&r" (ret.w0), "=&r" (ret.w1), "=&r" (status) :
                "r" (&_internal), "r" (des.two_dw.w0), "r" (des.two_dw.w1) :
                "memory");
      return two_64_to_128_type(ret).qw;
    }

    void _atomic_store(const shadow_type &desired) {
      _atomic_exchange(desired);
    }

    bool _atomic_compare_exchange(shadow_type &expected, const shadow_type &desired) {
      const two_64_to_128_type& des = static_cast<const two_64_to_128_type&>(desired);
      two_double_words_type &exp = reinterpret_cast<two_double_words_type&>(expected);
      two_double_words_type read;
      uint32_t status;
      asm volatile (
                "1: ldaxp %0, %1, [%5];"
                "   cmp %0, %3;"
                "   b.ne 2f;"
                "   cmp %1, %4;"
                "   b.ne 2f;"
                "   stlxp %w2, %6, %7, [%5];"
                "   cbnz %w2, 1b;"
                "   b 3f;"
                "2: stlxp %w2, %0, %1, [%5];"
                "   cbz %w2, 3f;"
                "   ldaxp %0, %1, [%5];"
                "   b 2b;"
                "3: cset %w2, eq;" :
                "=&r" (read.w0), "=&r" (read.w1), "=&r" (status) :
                "r" (exp.w0), "r" (exp.w1), "r" (&_internal), "r" (des.two_dw.w0), "r" (des.two_dw.w1) :
                "memory");

      if (status == 0) {
        exp = read;
        return false;
      }
      return true;
    }
  protected:
    constexpr static std::memory_order load_order(std::memory_order order) {
      return (order == std::memory_order_acq_rel ? std::memory_order_acquire
              : order == std::memory_order_release ? std::memory_order_relaxed
              : order);
    }
  public:
    constexpr atomic16B(const contained_type &desired)
      : _internal(shadow(desired))
    {}
    atomic16B() : atomic16B(contained_type())
    {}
    atomic16B(const atomic16B &) = delete;

    contained_type operator =(const contained_type &desired) {
      store(desired);
      return desired;
    }
    contained_type operator =(const contained_type &desired) volatile {
      store(desired);
      return desired;
    }
    atomic16B &operator =(const atomic16B &) = delete;
    atomic16B &operator =(const atomic16B &) volatile = delete;

    bool is_lock_free() const {
      return __atomic_is_lock_free(sizeof(T), 0);
    }
    bool is_lock_free() const volatile {
      return __atomic_is_lock_free(sizeof(T), 0);
    }

    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst)
    {
      _atomic_store(shadow(desired));
    }
    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      _atomic_store(shadow(desired));
    }

    contained_type load(std::memory_order order = std::memory_order_seq_cst) const
    {
      return unshadow(_atomic_load());
    }
    contained_type load(std::memory_order order = std::memory_order_seq_cst) const volatile
    {
      return unshadow(_atomic_load());
    }

    operator contained_type() const {
      return load();
    }
    operator contained_type() const volatile {
      return load();
    }

    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst)
    {
      return unshadow(_atomic_exchange(shadow(desired)));
    }
    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return unshadow(_atomic_exchange(shadow(desired)));
    }


    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure)
    {
      return _atomic_compare_exchange(shadow(expected), shadow(desired));
    }
    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }
    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure) volatile
    {
      return _atomic_compare_exchange(shadow(expected), shadow(desired));
    }
    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure)
    {
      return _atomic_compare_exchange(shadow(expected), shadow(desired));
    }
    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }
    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure) volatile
    {
      return _atomic_compare_exchange(shadow(expected), shadow(desired));

    }
    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }
  };

#elif defined(__x86_64)
template <typename T> using atomic16B = std::atomic<T>;
#endif /* __aarch64__ */
}

#endif /* ATOMIC16B_H_ */
