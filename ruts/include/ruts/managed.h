/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * managed.h
 *
 *  Created on: Aug 12, 2014
 *      Author: evank
 */

#ifndef MANAGED_H_
#define MANAGED_H_

#include <cstdlib>
#include <atomic>
#include <functional>
#include <string>
#include "pheap/pheap.h"

namespace ruts {

  class managed_placement_t {};
  static const managed_placement_t in_managed_space;

  class no_delete_t {};
  const no_delete_t no_delete;

  class managed_space {
    static std::string name();
    static std::size_t n_managed_slots();

    static pheap::persistent_heap &init_heap();

    class control_block;
    static control_block &find_control_block();

    static std::atomic<void *> &lookup_slot(std::size_t which);

    static pheap::persistent_heap &heap()
    {
      static pheap::persistent_heap &h = init_heap();
      return h;
    }

    static uint32_t &n_no_sync_regions()
    {
      static thread_local uint32_t n = 0;
      return n;
    }


    static control_block &cblock() {
      static control_block &cb = find_control_block();
      return cb;
    }

  public:
    struct no_sync_region : public pheap::persistent_heap::no_sync_region {
      no_sync_region() : pheap::persistent_heap::no_sync_region(heap()) {
        n_no_sync_regions()++;
      }
      ~no_sync_region() {
        n_no_sync_regions()--;
      }
    };


    template <typename Fn, typename...Args>
    static auto no_sync_during(const Fn &f, Args&&...args) -> decltype(f(std::forward<Args>(args)...))
    {
      no_sync_region nsr;
      return f(std::forward<Args>(args)...);
    }

    template <typename T>
    class allocator {
    public:
      using size_type = std::size_t;
      using difference_type = ptrdiff_t;
      using pointer = T*;
      using const_pointer = const T*;
      using reference = T&;
      using const_reference = const T&;
      using value_type = T;
      template <typename T2> struct rebind
      {
        using other = allocator<T2>;
      };
      using propagate_on_container_move_assignment = std::true_type;

      allocator() throw() {}
      allocator(const allocator&) throw() {}
      template <typename T2> allocator(const allocator<T2>&) throw() {}
      ~allocator() throw() {}

      pointer allocate(size_t n) {
        return static_cast<pointer>(heap().allocate(n * sizeof(T)));
      }

      void deallocate(pointer ptr, size_type n)
      {
        heap().deallocate(ptr);
      }

      template <typename U>
      void destroy(U *ptr)
      {
        ptr->~U();
      }

      template <typename U, typename... Args>
      void construct(U*ptr, Args&&... args)
      {
        new ((void*)ptr) U(std::forward<Args>(args)...);
      }
    };

    template <typename C, typename... Args>
    static C *create(Args &&... args)
    {
      no_sync_region nsr;
      allocator<C> a;
      C *ptr = a.allocate(1);
      a.construct(ptr, std::forward<Args>(args)...);
      return ptr;
    }

    template <typename C, typename... Args>
    static C *createArray(std::size_t n, Args &&... args)
    {
      no_sync_region nsr;
      allocator<C> a;
      C *ptr = a.allocate(n);
      for (int i=0; i<n; i++) {
        a.construct(ptr+i, std::forward<Args>(args)...);
      }
      return ptr;
    }

    template <typename C>
    static void destroy(C *ptr, std::size_t n = 1) {
      no_sync_region nsr;
      allocator<C> a;
      a.destroy(ptr);
      a.deallocate(ptr, n);
    }

    struct deleter {
      template <typename T>
      void operator()(T *ptr)
      {
        destroy(ptr);
      }
    };

    static void sync() {
      assert(n_no_sync_regions() == 0);
      heap().sync();
    }

    template <typename T>
    static T *lookup(std::size_t which)
    {
      std::atomic<void *> &slot = lookup_slot(which);
      return static_cast<T*>(slot.load());
    }


    template <typename T, typename Fn, typename ... Args>
    static T &find_or(std::size_t which, const Fn &fn, Args && ...args)
    {
      std::atomic<void *> &slot = lookup_slot(which);
      if (slot == nullptr) {
        T *ptr = fn(std::forward<Args>(args)...);
        void *null = nullptr;
        if (!slot.compare_exchange_strong(null, ptr)) {
          destroy(ptr);
        }
      }
      return *static_cast<T*>(slot.load());
    }
    template <typename T, typename Fn, typename ... Args>
    static T &find_or(std::size_t which, no_delete_t, const Fn &fn, Args && ...args)
    {
      std::atomic<void *> &slot = lookup_slot(which);
      if (slot == nullptr) {
        T *ptr = fn(std::forward<Args>(args)...);
        void *null = nullptr;
        if (!slot.compare_exchange_strong(null, ptr)) {
          // ignore
        }
      }
      return *static_cast<T*>(slot.load());
    }
    template <typename T, typename ... Args>
    static T &find_or_construct(std::size_t which, Args && ...args)
    {
      std::atomic<void *> &slot = lookup_slot(which);
      if (slot == nullptr) {
        T *ptr = create<T>(std::forward<Args>(args)...);
        void *null = nullptr;
        if (!slot.compare_exchange_strong(null, ptr)) {
          destroy(ptr);
        }
      }
      return *static_cast<T*>(slot.load());
    }


  };


  template <typename T1, typename T2>
  bool operator==(const managed_space::allocator<T1> &lhs, const managed_space::allocator<T2> &rhs) {
    // They're stateless, so they're always equal
    return true;
  }
  template <typename T1, typename T2>
  bool operator!=(const managed_space::allocator<T1> &lhs, const managed_space::allocator<T2> &rhs) {
    // They're stateless, so they're always equal
    return false;
  }


}


inline
void *operator new(std::size_t count, ruts::managed_placement_t) {
  ruts::managed_space::allocator<char>a;
  return a.allocate(count);
}
inline
void *operator new[](std::size_t count, ruts::managed_placement_t) {
  ruts::managed_space::allocator<char>a;
  return a.allocate(count);
}

namespace ruts {
  struct allocate_in_managed_space {
    void *operator new(size_t n) {
      return ::operator new(n, in_managed_space);
    }
    void *operator new[](size_t n) {
      return ::operator new[](n, in_managed_space);
    }
    /*
     * To allow it to be redundantly specified
     */
    void *operator new(size_t n, const managed_placement_t &) {
      return operator new(n);
    }
    void *operator new[](size_t n, const managed_placement_t &) {
      return operator new[](n);
    }
    void operator delete(void *ptr, std::size_t sz) {
      managed_space::allocator<allocate_in_managed_space> a;
      a.deallocate(static_cast<allocate_in_managed_space*>(ptr), sz);
    }
    void operator delete[](void *ptr, std::size_t sz) {
      managed_space::allocator<allocate_in_managed_space> a;
      a.deallocate(static_cast<allocate_in_managed_space*>(ptr), sz);
    }
  };

}

#endif /* MANAGED_H_ */
