/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * sesd_queue.h
 *
 *  Created on: Jul 15, 2015
 *      Author: gidra
 */

#ifndef LF_SESD_QUEUE_H_
#define LF_SESD_QUEUE_H_

#include<cstddef>
#include<atomic>
#include<memory>
#include<cassert>
/*
 * This class provides a lock-free unbounded queue implemented
 * using a singly linked-list. This provides concurrency between
 * single enqueue and single dequeue operations. That is why the
 * name sesd_queue.
 *
 * TODO: At present the implementation uses a lock. Need to make it truly
 * lock-free. It is safe as of now because the only user of this structure
 * is within a process.
 */

namespace ruts {
  template <typename T, typename A = std::allocator<T>>
  class sesd_queue {
     struct entry {
       T value;
       entry * volatile next;
     };

     using entry_allocator_type = typename std::allocator_traits<A>::template rebind_alloc<entry>;

     entry * volatile first;
     entry * volatile last;
     entry_allocator_type alloc;
     std::atomic_flag _lock;

     void lock() {
       while(_lock.test_and_set());
     }

     void unlock() {
       _lock.clear();
     }

     void enqueue(entry *e) {
       lock();
       if (is_empty()) {
         first = e;
         last = e;
       } else {
         last->next = e;
         last = e;
       }
       unlock();
     }
  public:
     sesd_queue() : first(nullptr), last(nullptr), alloc(), _lock(ATOMIC_FLAG_INIT) {
     }

     ~sesd_queue() {
       clear();
     }

     constexpr T *tail() const { return last ? &last->value : nullptr;}
     constexpr T *head() const { return first ? &first->value : nullptr;}

     constexpr bool is_empty() const { return last == nullptr;}

     void clear() {
       //Not thread-safe!
       while (first != nullptr) {
         entry *e = first;
         first = first->next;
         e->value.~T();
         alloc.deallocate(e, 1);
       }
     }

     template <typename ...Args>
     T *enqueue(Args&&... args) {
       entry *e = alloc.allocate(1);
       T *p = &(e->value);
       new (p) T(std::forward<Args>(args)...);
       e->next = nullptr;
       enqueue(e);
       return p;
     }

     T *dequeue() {
       T *ret = nullptr;
       lock();
       if (first) {
         ret = &(first->value);
         first = first->next;
         if (!first) {
           last = nullptr;
         }
       }
       unlock();
       return ret;
     }

     void destroy_entry(T *e) {
       alloc.deallocate(reinterpret_cast<entry*>(reinterpret_cast<uint8_t*>(e) - offsetof(entry, value)), 1);
     }
  };
}



#endif /* LF_SESD_QUEUE_H_ */
