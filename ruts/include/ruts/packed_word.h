/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * packed_word.h
 *
 *  Created on: Sep 2, 2014
 *      Author: evank
 */

#ifndef PACKED_WORD_H_
#define PACKED_WORD_H_

#include <cstddef>
#include <cstdint>
#include <utility>
#include <type_traits>
#include <atomic>
#include <type_traits>
#include "ruts/cas_loop.h"

namespace ruts {
  template <typename Word, typename ...Fields> class atomic_packed_word;
}

namespace ruts {
  template <typename Word, std::size_t Width, std::size_t Shift>
  struct __mask{
    using word_t = Word;
    constexpr static std::size_t width = Width;
    constexpr static std::size_t shift = Shift;
    constexpr static word_t unshifted_mask = (word_t{1} << width) - 1;
    constexpr static word_t shifted_mask = unshifted_mask << shift;
  };

  struct pad {};

  template <std::size_t W> struct skip {};

  /*
   * This was originally just field<T,W,Enabled>, but when we merged
   * the namespaces into ruts::, we started getting errors when using
   * "pw.template field<I>()", saying we had the wrong number of
   * template arguments.  As near as I can tell, this is a known bug
   * in GCC.  It's supposed to work right, but it was ill-formed
   * before C++11 and GCC apparently still doesn't do it right.
   *
   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54769
   */
  template <typename T, std::size_t W, typename Enabled = void> struct pw_field;

  template <typename T, std::size_t W>
  struct __field_defaults {
    using type = T;
    constexpr static std::size_t width = W;
    template <typename Word>
    constexpr static T from_word(Word word) {
      return static_cast<T>(word);
    }
    template <typename Word>
    constexpr static Word to_word(T val) {
      return static_cast<Word>(val);
    }

    template <typename Field>
    class reference {
    protected:
      using word_t = typename Field::word_t;
      constexpr static std::size_t shift = Field::shift;
      word_t &_word;
      // TODO: really shouldn't be there, but we need to be able to return a reference
//      reference(const reference &) = delete;
    public:
      using mask = __mask<word_t, width, shift>;
      reference(word_t &w) : _word{w} {}

      operator type() const {
        return Field::from(_word);
      }

      reference &operator =(const type &val) {
        using mask = __mask<word_t, width, shift>;
        word_t v = Field::as_field(val);
        _word = (_word & ~mask::shifted_mask) | v;
        return *this;
      }

      reference &operator =(const reference &rhs) {
        // the types, widths, and shifts match, so we can just copy
        _word = (_word & ~mask::shifted_mask) | (rhs._word & mask::shifted_mask);
        return *this;
      }

      template <typename U = T, typename =  std::enable_if_t<std::is_pointer<U>::value>>
      type operator->() const {
        return Field::from(_word);
      }

      template <typename U = T, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      reference &clear() {
        return (*this) = false;
      }
      template <typename U = T, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      reference &set() {
        return (*this) = true;
      }
      template <typename U = T, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      reference &flip() {
        return (*this) = !(*this);
      }

      template <typename U>
      reference &operator +=(const U &rhs) {
        return (*this) = (*this)+rhs;
      }
      template <typename U>
      reference &operator -=(const U &rhs) {
        return (*this) = (*this)-rhs;
      }
      template <typename U>
      reference &operator *=(const U &rhs) {
        return (*this) = (*this)*rhs;
      }
      template <typename U>
      reference &operator /=(const U &rhs) {
        return (*this) = (*this)/rhs;
      }
      template <typename U>
      reference &operator %=(const U &rhs) {
        return (*this) = (*this)%rhs;
      }
      template <typename U>
      reference &operator <<=(const U &rhs) {
        return (*this) = (*this)<<rhs;
      }
      template <typename U>
      reference &operator >>=(const U &rhs) {
        return (*this) = (*this)>>rhs;
      }
      template <typename U>
      reference &operator &=(const U &rhs) {
        return (*this) = (*this)&rhs;
      }
      template <typename U>
      reference &operator |=(const U &rhs) {
        return (*this) = (*this)|rhs;
      }
      template <typename U>
      reference &operator ^=(const U &rhs) {
        return (*this) = (*this)^rhs;
      }

      reference &operator ++() {
        return (*this) += 1;
      }
      reference &operator --() {
        return (*this) -= 1;
      }

      type operator++(int) {
        type val = *this;
        ++(*this);
        return val;
      }
      type operator--(int) {
        type val = *this;
        --(*this);
        return val;
      }

    };

  };

  template <>
  struct pw_field<bool, 1> : __field_defaults<bool, 1> {
    template <typename Word>
    constexpr static bool from_word(Word word) {
      return word != 0;
    }
    template <typename Word>
    constexpr static Word to_word(bool val) {
      return val ? Word{1} : Word{0};
    }

  };

  template <typename T, std::size_t W>
  struct pw_field<T*, W> : __field_defaults<T*, W> {
    template <typename Word>
    constexpr static T* from_word(Word word) {
      return reinterpret_cast<T*>(static_cast<std::uintptr_t>(word));
    }
    template <typename Word>
    constexpr static Word to_word(T* val) {
      return static_cast<Word>(reinterpret_cast<std::uintptr_t>(val));
    }
  };

  template <typename T, std::size_t W>
  struct pw_field<T,W,
  std::enable_if_t<(
      (std::is_integral<T>() && std::is_unsigned<T>())
      || std::is_enum<T>()
      )>
> : __field_defaults<T, W> {
  };

  template <typename T, std::size_t W>
  struct pw_field<T,W,
  std::enable_if_t<(
      std::is_integral<T>() && std::is_signed<T>())
      >
  > : __field_defaults<T, W> {
  private:
    template <typename Word, typename Mask>
    constexpr static Word from_1(Word word) {
      return (word >> Mask::shift) & Mask::unshifted_mask;
    }
    template <typename Word>
    constexpr static Word unshifted_sign_mask() {
      return Word{1} << (W-1);
    }
    template <typename Word>
    constexpr static Word sign_extension_mask() {
      return ~((Word{1}<<W)-1);
    }
    template <typename Word>
    constexpr static Word from_2(Word word) {
      return (word & unshifted_sign_mask<Word>()) != 0 ? word | sign_extension_mask<Word>() : word;
    }
  public:
    template <typename Word>
    constexpr static T from_word(Word word) {
      return static_cast<T>(from_2<Word>);
    }
  };


  template <typename Word, typename ...F> struct __traits_base;

  template <typename Word>
  struct __traits_base<Word> {
    using word_t = Word;
    constexpr static std::size_t word_size = 8*sizeof(word_t);
    constexpr static bool explicit_pad = false;
    constexpr static std::size_t pad_size = word_size;
    constexpr static std::size_t n_fields = 0;
  protected:
    constexpr static std::size_t bits_used(std::size_t pad) {
      return 0;
    }
    template <std::size_t I>
    constexpr static std::size_t shift_for(std::size_t psize) {
      // we should never get here.
      return 0;
    }
    template <std::size_t I>
    constexpr static std::size_t width_of() {
      // we should never get here.
      return 0;
    }
  };

  template <typename Word, typename ...F>
  struct __traits_base<Word, pad, F ...> : __traits_base<Word, F...> {
    using tail = __traits_base<Word, F...>;
    static_assert(!tail::explicit_pad, "More than one pad in packed word");
    constexpr static bool explicit_pad = true;
  protected:
    constexpr static std::size_t bits_used(std::size_t psize) {
      return psize+tail::bits_used(psize);
    }
    template <std::size_t I>
    constexpr static std::size_t shift_for(std::size_t psize) {
      return tail::template shift_for<I>(psize);
    }
  };

  template <typename Word, std::size_t W, typename ...F>
  struct __traits_base<Word, skip<W>, F ...> : __traits_base<Word, F...>
  {
    using tail = __traits_base<Word, F...>;
    static_assert(tail::pad_size >= W, "Too many bits specified");
    constexpr static std::size_t pad_size = tail::pad_size - W;
  protected:
    constexpr static std::size_t bits_used(std::size_t psize) {
      return W+tail::bits_used(psize);
    }
    template <std::size_t I>
    constexpr static std::size_t shift_for(std::size_t psize) {
      return tail::template shift_for<I>(psize);
    }
  };

  template <typename Word, typename T, std::size_t W, typename ...F>
  struct __traits_base<Word, pw_field<T, W>, F ...> : __traits_base<Word, F...>
  {
    using tail = __traits_base<Word, F...>;
    static_assert(tail::pad_size >= W, "Too many bits specified");
    constexpr static std::size_t pad_size = tail::pad_size - W;
    constexpr static std::size_t n_fields = tail::n_fields+1;
  protected:
    constexpr static std::size_t bits_used(std::size_t psize) {
      return W+tail::bits_used(psize);
    }
    template <std::size_t I>
    constexpr static std::size_t shift_for(std::size_t psize) {
      return I==0 ? tail::bits_used(psize) : tail::template shift_for<I-1>(psize);
    }
    template <std::size_t I>
    constexpr static std::size_t width_of() {
      return I==0 ? W : tail::template width_of<I-1>();
    }

  };

  template <std::size_t I, typename ...Fields> class __field_type;

  template <typename T, std::size_t W, typename ...Fields>
  struct __field_type<0, pw_field<T,W>, Fields...> {
    using type = T;
  };

  template <std::size_t I, typename T, std::size_t W, typename ...Fields>
  struct __field_type<I, pw_field<T,W>, Fields...> : __field_type<I-1, Fields...> {};

  template <std::size_t I, typename F, typename ...Fields>
  struct __field_type<I, F, Fields...> : __field_type<I, Fields...> {};







  template <std::size_t Next, typename Traits, typename...Args>
  class __combine_fields;

  template <std::size_t Next, typename Traits>
  struct __combine_fields<Next, Traits> {
    using word_t = typename Traits::word_t;
    constexpr static word_t value() {
      return word_t{};
    }
  };

  template <std::size_t To>
  struct __print_fields {
    template <typename PW, typename CharT, typename CharTraits>
    static std::basic_ostream<CharT, CharTraits> &print(std::basic_ostream<CharT, CharTraits> &out, const PW &pw) {
      return __print_fields<To-1>::print(out, pw)
          << " "
          << pw.template get_field<To-1>();
    }
  };
  template <>
  struct __print_fields<0> {
    template <typename PW, typename CharT, typename CharTraits>
    static std::basic_ostream<CharT, CharTraits> &print(std::basic_ostream<CharT, CharTraits> &out, const PW &pw) {
      return out;
    }
  };

  template <std::size_t I, typename T, typename Traits>
  struct __field {
    using type = T;
    using word_t = typename Traits::word_t;
    constexpr static std::size_t width = Traits::template field_width<I>();
    constexpr static std::size_t shift = Traits::template shift<I>();
    using mask = __mask<word_t,width,shift>;
    using field_spec = pw_field<type, width>;
    using reference = typename field_spec::template reference<__field>;
    constexpr static type from(word_t word) {
      using mask = __mask<word_t, width, shift>;
      return field_spec::template from_word<word_t>((word >> shift) & mask::unshifted_mask);
    }
    constexpr static word_t as_field(T val){
      using mask = __mask<word_t, width, shift>;
      return (field_spec::template to_word<word_t>(val) & mask::unshifted_mask) << shift;
    }


  };

  template <std::size_t Next, typename Traits, typename Arg, typename ... Args>
  struct __combine_fields<Next, Traits, Arg, Args...> {
    using word_t = typename Traits::word_t;
    using field_t = typename Traits::template field_type<Next>;
    constexpr static word_t value(Arg&& a, Args&&...args) {
      return field_t::as_field(a) | __combine_fields<Next+1, Traits, Args...>::value(std::forward<Args>(args)...);
    }
  };




  template <typename Word, typename ...F>
  struct __traits : __traits_base<Word, F...>
  {
  private:
    using base = __traits_base<Word, F...>;
  public:
    using word_t = typename base::word_t;
    template <std::size_t I, typename = std::enable_if_t<(I<base::n_fields)>>
        using field_type = __field<I, typename __field_type<I, F...>::type, __traits>;
    template <std::size_t I, typename = std::enable_if_t<(I<base::n_fields)>>
    constexpr static std::size_t shift()
    {
      return base::template shift_for<I>(base::pad_size);
    }
    template <std::size_t I, typename = std::enable_if_t<(I<base::n_fields)>>
    constexpr static std::size_t field_width()
    {
      return base::template width_of<I>();
    }
    template <typename ... Args>
    constexpr static word_t combine(Args&&...args) {
      static_assert(sizeof...(Args) == base::n_fields, "Wrong number of arguments");
      return __combine_fields<0, __traits, Args...>::value(std::forward<Args>(args)...);
    }


  };






  template <typename Word, typename ... Fields>
  class packed_word
  {
  public:
    using traits = __traits<Word, Fields...>;
    using word_t = typename traits::word_t;
    constexpr static std::size_t n_fields = traits::n_fields;
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>>
    using field_t = typename traits::template field_type<I>;
    using atomic_type = ruts::atomic_packed_word<Word, Fields...>;

  private:
    word_t _word;

  public:

    template <typename ... Args>
    constexpr std::enable_if_t<sizeof...(Args) == n_fields, word_t>
    combine(Args&& ...args) {
      return traits::combine(std::forward<Args>(args)...);
    }


    word_t word() const {
      return _word;
    }

    word_t &word() {
      return _word;
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    constexpr
    typename field_t<I>::type
    field() const {
      using f = field_t<I>;
      return f::from(_word);
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    field() {
      using f = field_t<I>;
      return typename f::reference{_word};
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type
    constexpr field(field_t<I>) const {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    field(field_t<I>) {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    constexpr
    typename field_t<I>::type
    get_field() const {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    get_field() {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    constexpr
    typename field_t<I>::type
    get_field(field_t<I>) const {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    get_field(field_t<I>) {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    set_field(const typename field_t<I>::value &val) {
      return field<I>() = val;
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    set_field(field_t<I>, const typename field_t<I>::value &val) {
      return field<I>() = val;
    }


    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    constexpr
    typename field_t<I>::type
    operator[](field_t<I>) const {
      return field<I>();
    }

    template <std::size_t I
    , typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::reference
    operator[](field_t<I>) {
      return field<I>();
    }

    packed_word() noexcept : _word(0) {}

    template <typename ... Args, typename = std::enable_if_t<(sizeof...(Args)==n_fields)>>
    packed_word(Args&& ... args) noexcept : _word(combine(std::forward<Args>(args)...))
    {

    }

    bool operator ==(const packed_word &rhs) const {
      return _word == rhs._word;
    }
    bool operator !=(const packed_word &rhs) const {
      return _word != rhs._word;
    }

    template <typename ... Args>
    packed_word &set(Args&& ... args) {
      _word = combine(std::forward<Args>(args)...);
      return *this;
    }

    packed_word &clear() {
      _word = 0;
      return *this;
    }

    template <std::size_t I, typename...Pairs
    , typename = std::enable_if_t<(I<n_fields)>
    >
    packed_word &set_fields(field_t<I>, const typename field_t<I>::type &val) {
      field<I>() = val;
      return *this;
    }

    template <std::size_t I, size_t J, typename...Pairs
    , typename = std::enable_if_t<(I<n_fields && J<n_fields)>
    >
    packed_word &set_fields(field_t<I> f1, const typename field_t<I>::type &v1,
                            field_t<J> f2, const typename field_t<J>::type &v2,
                            Pairs&&...pairs) {
      static_assert(sizeof...(Pairs)%2 == 0, "Odd number of arguments for set_fields");
      return set_fields(f1, v1).set_fields(f2, v2, std::forward<Pairs...>(pairs)...);
    }



    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out, const packed_word &ref) {
      out << "{";
      __print_fields<n_fields>::print(out, ref);
      return out << " }";
    }

  };

}

namespace ruts {
  template <typename Word, typename ...Fields>
  class atomic_packed_word {
  public:
    using packed_word_type = ruts::packed_word<Word, Fields...>;
  private:
    using atomic_type = std::atomic<packed_word_type>;
    atomic_type _atomic;
    packed_word_type pw() const {
      return _atomic.load();
    }
  public:
    using update_return = cas_loop_return_value<packed_word_type>;
    constexpr static std::size_t n_fields = packed_word_type::n_fields;
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>>
        using field_t = typename packed_word_type::template field_t<I>;

    atomic_packed_word() {}
    template <typename ... Args, typename = std::enable_if_t<(sizeof...(Args)==n_fields)>>
    atomic_packed_word(Args&& ... args) noexcept : _atomic(packed_word_type(std::forward<Args>(args)...))
    {

    }


    const atomic_type &underlying_atomic() const {
      return _atomic;
    }

    atomic_type &underlying_atomic() {
      return _atomic;
    }

    packed_word_type contents() const {
      return pw();
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &
    operator <<(std::basic_ostream<CharT,Traits> &out,
                const atomic_packed_word &apw)
    {
      return out << apw.contents();
    }

    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type field() const {
      return contents().get_field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type field(field_t<I>) const {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type operator[](field_t<I>) const {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type get_field() const {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type get_field(field_t<I>) const {
      return field<I>();
    }


    template <typename Continue, typename Update>
    update_return try_update(Continue cfn, Update ufn) {
      return try_cas_loop(_atomic, cfn, ufn);
    }

    template <typename Continue, typename Update>
    update_return try_update(std::size_t max_tries, Continue cfn, Update ufn) {
      return max_tries == 1 ? try_cas(_atomic, cfn, ufn) : try_cas_loop(_atomic, max_tries, cfn, ufn);
    }

    template <typename Update>
    update_return try_update(std::size_t max_tries, Update ufn) {
      return try_cas_loop(_atomic, max_tries, ufn);
    }

    template <typename Update>
    update_return update(Update ufn) {
      return cas_loop(_atomic, ufn);
    }

    update_return set(const packed_word_type &to) {
      return update([=](const packed_word_type &) { return to; });
    }

    update_return change(const packed_word_type &from, const packed_word_type &to) {
      return try_change_value(_atomic, from, to);
    }

    template <typename Update>
    update_return change_using(const packed_word_type &from, Update ufn) {
      return try_cas(_atomic, from, ufn(from));
    }

    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    update_return set_field(const typename field_t<I>::type &val) {
      return update([=](packed_word_type pw) {
        pw.field<I>() = val;
        return pw;
      });
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    update_return set_field(field_t<I>, const typename field_t<I>::type &val) {
      return set_field<I>(val);
    }

    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    update_return change_field(const packed_word_type &from, const typename field_t<I>::type &val) {
      return change_using(from, [=](packed_word_type pw) {
        pw.field<I>() = val;
        return pw;
      });
    }


    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>>
    class field_ref_t {
    public:
      using field_t = typename packed_word_type::template field_t<I>;
      constexpr static std::size_t num = I;
      using type = typename field_t::type;
    private:
      atomic_packed_word &_apw;
      explicit field_ref_t(atomic_packed_word &apw) : _apw(apw) {}
      friend class atomic_packed_word;
    public:
      operator typename field_t::type() const {
        return _apw.field<I>();
      }
      field_ref_t &operator =(const typename field_t::type &val) {
        _apw.set_field<num>(val);
        return *this;
      }


      template <typename U = type, typename =  std::enable_if_t<std::is_pointer<U>::value>>
      type operator->() const {
        return _apw.field<I>();
      }

      template <typename U = type, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      field_ref_t &clear() {
        return (*this) = false;
      }
      template <typename U = type, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      field_ref_t &set() {
        return (*this) = true;
      }
      template <typename U = type, typename = std::enable_if_t<std::is_same<U, bool>::value>>
      field_ref_t &flip() {
        return (*this) = !(*this);
      }

      template <typename U>
      field_ref_t &operator +=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() += rhs;
          return pw;
        });

      }
      template <typename U>
      field_ref_t &operator -=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() -= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator *=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() *= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator /=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() /= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator %=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() %= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator <<=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() <<= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator >>=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() >>= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator &=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() &= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator |=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() |= rhs;
          return pw;
        });
      }
      template <typename U>
      field_ref_t &operator ^=(const U &rhs) {
        return _apw.update([=](packed_word_type pw) {
          pw.field<num>() ^= rhs;
          return pw;
        });
      }

      field_ref_t &operator ++() {
        return (*this) += 1;
      }
      field_ref_t &operator --() {
        return (*this) -= 1;
      }

      type operator++(int) {
        type val = *this;
        ++(*this);
        return val;
      }
      type operator--(int) {
        type val = *this;
        --(*this);
        return val;
      }


    };

    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    field_ref_t<I> field() {
      return field_ref_t<I>{*this};
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    field_ref_t<I> field(field_t<I>) {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    field_ref_t<I> operator[](field_t<I>) {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type get_field() {
      return field<I>();
    }
    template <std::size_t I, typename = std::enable_if_t<(I<n_fields)>
    >
    typename field_t<I>::type get_field(field_t<I>) {
      return field<I>();
    }

  };
}



#endif /* PACKED_WORD_H_ */
