/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * flag_set.h
 *
 *  Created on: Sep 3, 2014
 *      Author: evank
 */

#ifndef FLAG_SET_H_
#define FLAG_SET_H_

#include <cstdint>
#include <iostream>
#include <utility>
#include <type_traits>
//#include "packed_word.h"
#include "ruts/ints.h"

namespace ruts {

  template <typename R = std::uint64_t>
  class flag_reference {
    using rep_type = R;
    rep_type &_flags;
    rep_type _mask;
  public:
    constexpr flag_reference(rep_type &flags, std::size_t flag, std::size_t offset = 0) : _flags(flags), _mask(rep_type{1}<<(flag+offset)) {}
    constexpr operator bool() const {
      return (_flags & _mask) != 0;
    }
    flag_reference &set() {
      _flags |= _mask;
      return *this;
    }
    flag_reference &clear() {
      _flags &= ~_mask;
      return *this;
    }
    flag_reference &flip() {
      _flags ^= _mask;
      return *this;
    }
    flag_reference &operator =(bool b) {
      return b ? set() : clear();
    }
  };

  template <typename R, typename ...Args> class __to_rep;

  template <typename R>
  struct __to_rep<R> {
    constexpr static R compute() {
      return R{};
    }
  };

  template <typename R, typename A, typename ...Args>
  struct __to_rep<R, A, Args...> {
    constexpr static R compute(A&& a, Args&&...args) {
      return (R{1} << a) | __to_rep<R, Args...>::compute(std::forward<Args>(args)...);
    }
  };

  template <std::size_t N>
  class flag_set {
  public:
    using rep_type = typename ints::uint_t<N>::fast;
    using reference = flag_reference<rep_type>;
    constexpr static std::size_t n_flags = N;
  private:
    rep_type _flags;
  public:
    constexpr explicit flag_set(rep_type fs = 0) : _flags(fs) {}

    template <typename ...Args>
    constexpr static flag_set of(Args && ...args) {
      return flag_set{__to_rep<rep_type, Args...>::compute(std::forward<Args>(args)...)};
    }
    constexpr operator rep_type() const {
      return _flags;
    }

    constexpr bool flag(std::size_t f) const {
      return (_flags & (1<<f)) != 0;
    }
    constexpr bool operator[](std::size_t f) const {
      return flag(f);
    }
    template <std::size_t F
    , typename = std::enable_if_t<(F<n_flags)>
    >
    constexpr bool flag() const {
      return flag(F);
    }
    reference flag(std::size_t f) {
      return reference(_flags, f, 0);
    }
    reference operator[](std::size_t f) {
      return flag(f);
    }
    template <std::size_t F
    , typename = std::enable_if_t<(F<n_flags)>>
    reference flag() {
      return flag(F);
    }
    constexpr bool is_empty() {
      return _flags == 0;
    }
    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out, const flag_set&ref) {
      out << "[";
      for (std::size_t i=n_flags; i>0; i--) {
        out << " " << ref[i-1];
      }
      return out << " ]";
    }
  };

  template <std::size_t NF, std::size_t W>
  struct pw_field<flag_set<NF>, W> : __field_defaults<flag_set<NF>, W> {
  private:
    using base = __field_defaults<flag_set<NF>,W>;
    using typename base::type;
    using base::width;
  public:
    template <typename Field>
    struct reference : base::template reference<Field> {
    private:
      using ref_base = typename base::template reference<Field>;
      using typename ref_base::word_t;
      using ref_base::_word;
      using ref_base::shift;
      constexpr static word_t bit_mask(std::size_t i) {
        return word_t{1} << (ref_base::shift + i);
      }
      using typename ref_base::mask;
    public:
      using flag_ref_t = flag_reference<word_t>;
      using ref_base::ref_base;
      constexpr bool operator[](std::size_t i) const {
        return _word & bit_mask(i);
      }
      flag_ref_t operator[](std::size_t i) {
        flag_ref_t fr{_word, i, ref_base::shift};
        return fr;
      }
      reference &operator =(const type &val) {
        using mask = __mask<word_t, width, shift>;
        word_t v = Field::as_field(val);
        _word = (_word & ~mask::shifted_mask) | v;
        return *this;
      }

      reference &operator =(const reference &rhs) {
        // the types, widths, and shifts match, so we can just copy
        _word = (_word & ~mask::shifted_mask) | (rhs._word & mask::shifted_mask);
        return *this;
      }

      template <typename U>
      reference &operator &=(const U &rhs) {
        return (*this) = (*this)&rhs;
      }
      template <typename U>
      reference &operator |=(const U &rhs) {
        return (*this) = (*this)|rhs;
      }
      template <typename U>
      reference &operator ^=(const U &rhs) {
        return (*this) = (*this)^rhs;
      }




    };
  };


}


#endif /* FLAG_SET_H_ */
