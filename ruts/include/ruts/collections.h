/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * multiset.h
 *
 *  Created on: Jul 20, 2015
 *      Author: gidra
 */

#ifndef LF_COLLECTIONS_H_
#define LF_COLLECTIONS_H_

#include<atomic>
#include<memory>
#include<cassert>

/*
 * Multiset implemented using a stack. Provides concurrent
 * inserts and traversal, or concurrent inserts and deletes,
 * but no concurrent traversal and deletes.
 * Deletes are handled lazily. Basically, elements are "marked"
 * for deletion, and later marked elements are deleted in different
 * (thread-unsafe) ways.
 *
 * The name of the class should be changed appropriately.
 */

namespace ruts {
  template <typename T, typename A>
      class collection {
    struct entry {
      T value;
      entry *next;
    };

    using entry_allocator_type = typename std::allocator_traits<A>::template rebind_alloc<entry>;

    std::atomic<entry *> _head;
    entry_allocator_type alloc;

    void insert(entry *e) {
      entry *temp = _head.load();
      do {
        e->next = temp;
        if (_head.compare_exchange_weak(temp, e))
          break;
      } while(true);
    }
      protected:
    collection(): _head(nullptr), alloc() {}

    ~collection() {
      while (_head.load()) {
        delete_head();
      }
    }

    void delete_next(T *p) {
      assert(p);
      entry *e = reinterpret_cast<entry*>(p);
      entry *ne = e->next;
      if (ne) {
        e->next = ne->next;
        ne->value.~T();
        alloc.deallocate(ne, 1);
      }
    }
    void delete_head() {
      entry *h = _head.load();
      while (h) {
        if (_head.compare_exchange_weak(h, h->next)) {
          h->value.~T();
          alloc.deallocate(h, 1);
          break;
        }
      }
    }

    bool delete_head(T *&p) {
      entry *h = reinterpret_cast<entry*>(p);
      if (_head.compare_exchange_strong(h, h->next)) {
        h->value.~T();
        alloc.deallocate(h, 1);
        return true;
      }
      p = reinterpret_cast<T*>(h);
      return false;
    }

      public:
    constexpr T *head() const {
      entry *h = _head.load();
      return h ? &(_head.load()->value) : nullptr;
    }

    constexpr T *next(T *p) const {
      assert(p);
      entry *ne = reinterpret_cast<entry*>(p)->next;
      return ne ? &(ne->value) : nullptr;
    }

    template <typename ...Args>
    T *insert(Args&&... args) {
      entry *e = alloc.allocate(1);
      T *p = &(e->value);
      new (p) T(std::forward<Args>(args)...);
      insert(e);
      return p;
    }

    template <typename ...Args>
    void insert(T* &p, Args&&... args) {
      entry *e = alloc.allocate(1);
      p = &(e->value);
      new (p) T(std::forward<Args>(args)...);
      insert(e);
    }
  };

  /*
   * In this variant of collection, every thread/process
   * deletes all the marked elements between its own element
   * and the next live element.
   */
  template <typename T, typename A = std::allocator<T>>
      class parallel_lazy_delete_collection : public collection<T, A> {
    using base = collection<T, A>;
      public:
    template <typename Pred>
    void deletion(T *p, Pred&& is_marked) {
      for (T *n = base::next(p); n && std::forward<Pred>(is_marked)(n); n = base::next(p)) {
        base::delete_next(p);
      }
    }
  };

  /*
   * In this variant of collection, a single thread/process
   * deletes all the marked elements at a time when it is
   * guaranteed that no other thread could be adding elements
   * to the collection.
   */
  template <typename T, typename A = std::allocator<T>>
      class sequential_lazy_delete_collection : public collection<T, A> {
    using base = collection<T, A>;
      public:
    template <typename Pred>
    void deletion(Pred&& is_marked) {
      T *h = base::head();
      if (h == nullptr)
        return;

      while (std::forward<Pred>(is_marked)(h)) {
        /* If we fail, then h, being passed by reference, will have the
         * latest value. So no need to read _head again.
         */
        if (base::delete_head(h)) {
          h = base::head();
        }
        if (h == nullptr)
          return;
      }

      for (T *n = base::next(h); n; n = base::next(h)) {
        if (std::forward<Pred>(is_marked)(n))
          base::delete_next(h);
        else
          h = n;
      }
    }
  };
}



#endif /* LF_COLLECTIONS_H_ */
