/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mash.h
 *
 *  Created on: Sep 20, 2014
 *      Author: evank
 */

#ifndef MASH_H_
#define MASH_H_

#include <cstdint>
#include <random>
#include <array>
#include <string>
#include <cstring>
#include <utility>
#include <tuple>
#include <algorithm>
#include <type_traits>

#include "ruts/util.h"
#include <iostream>


namespace ruts {
  template <std::size_t N> struct _split_and_apply;
  template <>
  struct _split_and_apply<1> {
    template <typename Fn>
    void operator()(const char *ptr, Fn&& func) const {
      std::uint16_t n = *(reinterpret_cast<const std::uint8_t *>(ptr));
      func(n);
    }
  };
  template <>
  struct _split_and_apply<2> {
    template <typename Fn>
    void operator()(const char *ptr, Fn&& func) const {
      func(*reinterpret_cast<const std::uint16_t*>(ptr));
    }
  };
  template <>
  struct _split_and_apply<4> {
    template <typename Fn>
    void operator()(const char *ptr, Fn&& func) const {
      _split_and_apply<2>{}(ptr, func);
      _split_and_apply<2>{}(ptr+2, func);
    }
  };
  template <>
  struct _split_and_apply<8> {
    template <typename Fn>
    void operator()(const char *ptr, Fn&& func) const {
      _split_and_apply<4>{}(ptr, func);
      _split_and_apply<4>{}(ptr+4, func);
    }
  };
  template <>
  struct _split_and_apply<16> {
    template <typename Fn>
    void operator()(const char *ptr, Fn&& func) const {
      _split_and_apply<8>{}(ptr, func);
      _split_and_apply<8>{}(ptr+8, func);
    }
  };

  template <typename T, typename Enable = void> class add_to_mash_accumulator;

  class masher {
  public:
    using hash_type = uint64_t;
  private:
    using table_type = std::array<hash_type, std::numeric_limits<std::uint16_t>::max()+1>;
    const hash_type _null;
    const hash_type _start;
    table_type _table;


    class from_random_source {};
    template <typename R>
    masher(from_random_source, R mt)
    : _null{mt()}, _start{mt()}
    {
      for (std::uint64_t &entry : _table)
      {
        entry = mt();
      }
    }

  public:
    struct accumulator_type {
      hash_type hash;
      const table_type &table;
      accumulator_type(hash_type start, const table_type &t) : hash{start}, table(t) {}

      hash_type value() const {
        return hash;
      }
      operator hash_type() const {
        return hash;
      }



      accumulator_type &add(std::uint16_t val) {
        hash = ruts::rotate(hash);
        hash_type mapped = table[val];
        hash += mapped;

        return *this;
      }
      template <typename T>
      accumulator_type &add(const T &val) {
        add_to_mash_accumulator<T>{}(val, *this);
        return *this;
      }

      template <typename T, typename U, typename...Args>
      accumulator_type &add(const T &val, const U &next, Args&&...args) {
        add(val);
        return add(next, std::forward<Args>(args)...);
      }

      template <typename Iter>
      accumulator_type &add_range(const Iter &from, const Iter &to) {
        std::for_each(from, to, [this](decltype(*from) elt) {
          add(elt);
        });
        return *this;
      }

    };

    template <typename Random = std::mt19937_64>
    masher(hash_type seed)
    : masher(from_random_source{}, std::independent_bits_engine<Random, 64, hash_type>{seed})
    {}
    masher(const std::string &seed_phrase) : masher(std::hash<std::string>{}(seed_phrase)) {}

    accumulator_type accumulator() const {
      return accumulator_type{_start, _table};
    }

    template <typename Iter>
    hash_type over_range(const Iter& from, const Iter &to) {
      return accumulator().add_range(from, to);
    }

    template <typename ...Args>
    hash_type over(Args&&...args) {
      return accumulator().add(std::forward<Args>(args)...);
    }
    template <typename ...Args>
    hash_type operator()(Args&&...args) {
      return over(std::forward<Args>(args)...);
    }


    template <typename CharT, typename Traits, typename Accum>
    hash_type operator()(const std::basic_string<CharT, Traits, Accum> &s) {
      return accumulator().add(s);
    }

  };

  template <typename T>
  struct add_to_mash_accumulator<T, std::enable_if_t<std::is_arithmetic<T>::value>>
  {
    void operator()(const T &val, masher::accumulator_type &accum) {
      _split_and_apply<sizeof(T)>{}(reinterpret_cast<const char *>(&val),
          [&](std::uint16_t elt) { accum.add(elt); });
    }


  };
  template <typename CharT, typename Traits, typename Accum>
  struct add_to_mash_accumulator<std::basic_string<CharT,Traits,Accum>>
  {
    void operator()(const std::basic_string<CharT,Traits,Accum> &s, masher::accumulator_type &accum) {
      accum.add_range(s.begin(), s.end());
    }
  };

  /*
   * Null-terminated c string to handle literals.  It would be a mistake to pass any other sort of
   * character buffer in.
   */
  template<std::size_t N>
  struct add_to_mash_accumulator<char [N]> {
    void operator()(const char *s, masher::accumulator_type &accum) {
      accum.add_range(s, s+N-1);
    }
  };
  /*
   * Null-terminated c string to handle literals through make_tuple or make_pair.
   */
  template<>
  struct add_to_mash_accumulator<const char *> {
    void operator()(const char *s, masher::accumulator_type &accum) {
      std::size_t len = std::strlen(s);
      accum.add_range(s, s+len);
    }
  };

  template <typename I>
  struct add_to_mash_accumulator<ruts::range<I>> {
    void operator()(const ruts::range<I> &r, masher::accumulator_type &accum) {
      accum.add_range(r.begin(), r.end());
    }
  };

  template <typename T, typename U>
  struct add_to_mash_accumulator<std::pair<T,U>> {
    void operator()(const std::pair<T,U> &val, masher::accumulator_type &accum) {
      accum.add(val.first);
      accum.add(val.second);
    }
  };

  /*
   * This will be easier with C++14's integer_sequence, which will allow us to
   * simply use std::forward<Ts>(std::get<Seq>(tuple))...
   */

  template <std::size_t Next, std::size_t Len, typename ...Ts>
  struct _atma_tuple {
    static void doit(const std::tuple<Ts...> &tuple, masher::accumulator_type &accum) {
      accum.add(std::get<Next>(tuple));
      _atma_tuple<Next+1, Len, Ts...>::doit(tuple, accum);
    }
  };

  template <std::size_t Len, typename ...Ts>
  struct _atma_tuple<Len, Len, Ts...>
  {
    static void doit(const std::tuple<Ts...> &tuple, masher::accumulator_type &accum) {}
  };

  template <typename ...Ts>
  struct add_to_mash_accumulator<std::tuple<Ts...>> {
    void operator()(const std::tuple<Ts...> &tuple, masher::accumulator_type &accum) {
      _atma_tuple<0, sizeof...(Ts), Ts...>::doit(tuple, accum);
    }
  };


  template <typename Iter>
  std::pair<masher::hash_type, masher::hash_type>
  mash__range_pair(const masher &m1, const masher &m2, Iter from, Iter to) {
    masher::accumulator_type a1 = m1.accumulator();
    masher::accumulator_type a2 = m2.accumulator();
    std::for_each(from, to, [&](decltype(*from) elt) {
      a1.add(elt);
      a2.add(elt);
    });
    return std::make_pair(a1.value(), a2.value());
  }

  template <typename T>
  void mash_in_parallel(masher::accumulator_type &a1,
                        masher::accumulator_type &a2,
                        const T &val)
  {
    a1.add(val);
    a2.add(val);
  }

  template <typename T, typename U, typename ... Args>
  void mash_in_parallel(masher::accumulator_type &a1,
                        masher::accumulator_type &a2,
                        const T &val,
                        const U &next,
                        Args&&...args)
  {
    mash_in_parallel(a1, a2, val);
    mash_in_parallel(a1, a2, next, std::forward<Args>(args)...);
  }

  template <typename ...Args>
  std::pair<masher::hash_type, masher::hash_type>
  mash_pair(const masher &m1, const masher &m2, Args&&...args) {
    masher::accumulator_type a1 = m1.accumulator();
    masher::accumulator_type a2 = m2.accumulator();
    mash_in_parallel(a1, a2, std::forward<Args>(args)...);
    return std::make_pair(a1.value(), a2.value());
  }

}




#endif /* MASH_H_ */
