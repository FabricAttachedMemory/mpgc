/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "pheap/pheap_barrier.h"

using namespace pheap;
using namespace std;




bool barrier::enter_for_sync() {
	unique_lock<mutex> lck(_mutex);
	compound_state s = current();
	spin_loop loop;
	while (loop()) {
		if (s._state == Mutating) {
			if (update_state(s, 0, +1)) {
				bool val;
				_sync_okay.wait(lck, [this, &val](){
					compound_state s = current();
					switch (s._state) {
					case Allowing:
						val = true;
						spin_until([this, &s](){
							// The only other thing that can happen here is
							// a mutator entry, which doesn't change the state
							// spin
							assert(s._state == Allowing);
							return update_state(s, Syncing, 0, 0);
						});
						return true;
					case Syncing:
						// Somebody beat us to it.
						val = false;
						return true;
					default:
						return false;
					}
				});
				return val;
			}
		} else {
			state next = s._state == Unwinding ? Unwinding : Syncing;
			if (update_state(s, next, 0, +1)) {
				return s._state == Allowing || s._state == Idle;
			}
		}
	}
	assert(false);
	return false;
}

void barrier::unwind(compound_state &s, bool did_sync) {
	// mutex must be locked
	spin_loop loop;
	while (loop()) {
		state next = s.n_sync_regions > 1 ? Unwinding : s.n_mutate_regions == 0 ? Idle : Mutating;
		if (update_state(s, next, 0, -1)) {
			if (did_sync && next == Unwinding) {
				_sync_done.notify_all();
			} else if (next == Mutating) {
				_mutate_okay.notify_all();
			}
			return;
		}
	}
}

void barrier::exit_for_sync(bool did_sync) {
	unique_lock<mutex> lck(_mutex);
	compound_state s = current();
	if (did_sync) {
		assert(s._state == Syncing);
		unwind(s, true);
	} else {
		if (s._state == Syncing) {
			_sync_done.wait(lck, [this, &s]() {
				return (s = current())._state == Unwinding;
			});
		}
		assert(s._state == Unwinding);
		unwind(s, false);
	}
}




