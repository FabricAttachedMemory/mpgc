/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * pheap.cpp
 *
 *  Created on: Sep 17, 2013
 *      Author: evank
 */

#include "pheap/pheap_debug.h"
#include "pheap_impl.h"
#include "ruts/util.h"
#include "pheap_util.h"
#include <memory>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <cassert>
#include <unistd.h>



using namespace pheap;
using std::string;

void pheap::in_heap_deallocate(in_heap_header *header, barrier &_barrier, void *ptr) {
  if (ptr == nullptr) {
    return;
  }
  mutate_region region(_barrier);
  block *b = block::from(ptr);
  if (!header->check_pointer(b)) {
    // TODO
    return;
  }
  auto size_class = b->_size_class;
  header->free_lists[size_class].push(b);
}

void *pheap::in_heap_allocate(in_heap_header *header, barrier &_barrier, size_t n) {
  if (n == 0) {
    return nullptr;
  }
  size_t leading_zeroes = __builtin_clzl(n);
  size_t lg = 63-leading_zeroes;
  if (n != size_t{1} << lg) {
    lg++;
  }
  size_t size_class = lg < 4 ? 0 : lg - 4;
  mutate_region region(_barrier);
  block *b = header->free_lists[size_class].pop();
  if (b == nullptr) {
    b = header->new_block(size_class);
  }
  b->_next_free = nullptr;
  b->_freep = false;
  return b->data();
}

void persistent_heap::sync() {
	sync_region region(*_barrier);
	if (region) {
		dout << "Syncing" << std::endl;
		header->sync();
	}
}



in_heap_header *in_heap_header::place_at(void *loc, size_t size) {
  //  cerr << "Placing heap at " << loc << std::endl;
  //  cerr << "  Size is " << hex << size << std::endl;
  in_heap_header *h = new(loc) in_heap_header(loc);
  h->size = size;
  //  cerr << "  Header size is " << sizeof(in_heap_header) << std::endl;
  void *space = h+1;
  //  cerr << "  Free space could start at " << space << std::endl;
  size -= sizeof(in_heap_header);
  //  cerr << "  Free space size could be " << hex << size << std::endl;
  //	void *free_start = std::align(alignof(block), sizeof(unallocated_block), space, size);
  void *free_start = gcc_missing::align(16, sizeof(block), space, size);
  //  cerr << "  After alignment, free space starts at " << free_start<< std::endl;
  //  cerr << "                   free space size is " << size<< std::endl;
  if (free_start == nullptr) {
    return nullptr;
  }
  size_t n_blocks = size/16;
  pheap::block* b = static_cast<block*>(free_start);
  //  cerr << "Big block has size " << b->size<< " blocks" << std::endl;
  h->first_block_in_mem = b;
  h->first_unallocated_block = b;
  h->first_impossible_block = b+n_blocks;
  //  cerr << "First implossible block is " << h->first_impossible_block << std::endl;
  return h;
}


persistent_heap::persistent_heap(string name) : header(in_heap_header::load(name)), _barrier(new barrier) {
}

namespace {
	constexpr uint64_t kB() { return 1024; }
	constexpr uint64_t MB() { return 1024*kB(); }
	constexpr uint64_t GB() { return 1024*MB(); }
	constexpr uint64_t TB() { return 1024*GB(); }

	inline size_t pagesize() {
		static const size_t size = sysconf(_SC_PAGESIZE);
		return size;
	}

	class open_fd {
	public:
		open_fd(const string &name) : _fd(open(name.c_str(), O_RDWR, S_IRUSR | S_IWUSR)) {
			assert(_fd != -1);
		}
		~open_fd() {
			int r = close(_fd);
			assert(r == 0);
		}
		operator int() {
			return _fd;
		}
	private:
		const int _fd;
	};

	/*
	int get_file_descriptor(const string& name) {
		int fd = open(name.c_str(), O_RDWR, S_IRUSR | S_IWUSR);
		assert(fd != -1);
		return fd;
	}
	*/

	off_t heap_size(int fd) {
		struct stat st;
		int r = fstat(fd, &st);
		assert(r == 0);
		off_t heapsize = st.st_size;
		assert(heapsize > static_cast<int64_t>(sizeof(in_heap_header)));
//		using namespace std;
//		cout << "heapsize: " << heapsize << endl;
//		cout << "pagesize: " << pagesize() << endl;
		assert(heapsize % pagesize() == 0);
		return heapsize;
	}

	void* old_load_location(int fd) {
		void *loaded_at = mmap(nullptr, sizeof(in_heap_header), PROT_READ,
				MAP_PRIVATE, fd, 0);
		assert(loaded_at != MAP_FAILED);
		ruts::reset_flags_on_exit rf{std::cout};
		dout << "First load at " << std::hex << loaded_at << std::endl;
		in_heap_header* header = static_cast<in_heap_header*>(loaded_at);
		void* was_loaded_at = header->loaded_at;
		int r = munmap(loaded_at, sizeof(in_heap_header));
		assert(r == 0);
		return was_loaded_at;
	}

	void *find_big_hole(uint64_t holesize, uint64_t leftpad, size_t pagesize) {
		// TODO: Just make it return where it wants to put it.
		return reinterpret_cast<void *>(0x6ffffff0000);
//		using namespace std;
//		cout << "holesize: " << holesize << " (" << holesize/TB() << " TB)" << endl;
		void *p = mmap(nullptr, holesize, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
		assert(p != MAP_FAILED);
		void *middle = static_cast<char *>(p)+leftpad;
		uint64_t size = holesize-leftpad;
		void *aligned = gcc_missing::align(pagesize, pagesize, middle, size);
		int r = munmap(p, holesize);
		assert(r == 0);
		return aligned;
	}

	inline bool aligned(void *ptr, size_t alignment) {
		char *cp = static_cast<char*>(ptr);
		char *cnull = nullptr;
		ptrdiff_t diff = cp - cnull;
		return diff % alignment == 0;
	}


	in_heap_header *load_heap(const string &name) {
		open_fd fd(name);

		size_t heapsize = heap_size(fd);
		void* was_loaded_at = old_load_location(fd);
		if (was_loaded_at == nullptr) {
			void *hole = find_big_hole(15*TB(), 7*TB(), pagesize());
			for (int i=0; i<10; i++) {
				void *p = mmap(hole, heapsize, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED /*| MAP_ATOMIC*/, fd, 0);
				if (p != MAP_FAILED) {
					assert(p == hole);
					in_heap_header *header = static_cast<in_heap_header *>(p);
					header->place_at(p, heapsize);
					return header;
				}
				hole = static_cast<char*>(hole)+1*GB();
			}
			assert(false);
			return nullptr;
		} else {
			assert(aligned(was_loaded_at, pagesize()));
			void *p = mmap(was_loaded_at, heapsize, PROT_READ | PROT_WRITE, MAP_SHARED /* MAP_FIXED | MAP_ATOMIC*/, fd, 0);
			assert(p != MAP_FAILED);
			assert(p == was_loaded_at);
			in_heap_header *header = static_cast<in_heap_header *>(p);
			return header;
		}
	}

}


in_heap_header *in_heap_header::load(const string &name) {
	return load_heap(name);
}

void in_heap_header::sync() {
	int r = msync(this, size, MS_SYNC);
	assert(r == 0);
}

void *persistent_heap::get_raw_root() const {
	return header->root();
}

bool persistent_heap::set_raw_root(void *new_root) {
  return header->set_root(new_root, *_barrier);
}


