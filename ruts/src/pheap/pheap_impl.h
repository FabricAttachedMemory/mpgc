/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * pheap_impl.h
 *
 *  Created on: Sep 20, 2013
 *      Author: evank
 */

#ifndef PHEAP_IMPL_H_
#define PHEAP_IMPL_H_

#include "pheap/pheap.h"
#include "ruts/versioned_ptr.h"
#include <string>
#include <atomic>
#include <iostream>

namespace pheap {
  class /*alignas(16)*/ block {
  public:
    block *_next_free = nullptr;
    uint8_t _size_class;
    bool _freep = true;

    void *data() {
      return static_cast<void*>(this+1);
    }

    std::size_t n_blocks() const {
      return std::size_t{1} << _size_class;
    }
    std::size_t size() const {
      return n_blocks() << 4;
    }

    bool check_handed_out(block *min, block *max) const {
      return this >=min && this <=max && !_freep;
    }


    static block *from(void *ptr) {
      block *b = ptr == nullptr ? nullptr : static_cast<block *>(ptr)-1;
      return b;
    }


    explicit block(size_t size_class) : _size_class(size_class) {}

    block() = delete;
    block(const block &) = delete;
    block(block &&) = delete;
    block &operator =(const block &) = delete;
    block &operator =(block &&) = delete;
  };

  static_assert(sizeof(block) == 16, "A block needs to be 16 bytes");


  class free_list {
  private:
    ruts::atomic_versioned<block *> _head{nullptr};
  public:
    void push(block *b) {
      b->_freep = true;
      _head.update([=](ruts::versioned<block *> h) {
	  b->_next_free = h;
	  h.inc_and_set(b);
	  return h;
	});
    }

    block *pop() {
      auto clrv = _head.try_update([](ruts::versioned<block *> h) {
	  return h != nullptr;
	}, [](ruts::versioned<block *> h) {
	  h.inc_and_set(h->_next_free);
	  return h;
	});
      if (clrv) {
	return clrv.prior_value;
      } else {
	return nullptr;
      }
    }

  };
  class in_heap_header {
  public:
    bool check_pointer(const block *b) const {
      return b != nullptr && b->check_handed_out(first_block_in_mem, first_impossible_block);
    }

    block *new_block(size_t size_class) {
      size_t s = (size_t{1} << size_class)+1;
      block *fub = first_unallocated_block;
      while (fub+s <= first_impossible_block) {
        if (first_unallocated_block.compare_exchange_weak(fub, fub+s)) {
          new (fub) block{size_class};
          return fub;
        }
      }
      size_t bytes = (s-1)*sizeof(block);
      std::cerr << "Failed to allocate " << std::dec << bytes << "-byte (0x" << std::hex << bytes << std::dec << ") block in persistent heap." << std::endl;
      return nullptr;
    }
    void *allocate(size_t n);
    void deallocate(void *ptr);

    void *root() const {
      return root_obj;
    }
    bool set_root(void *new_root, pheap::barrier &_barrier);


    void *loaded_at;
    std::size_t size;
    block *first_block_in_mem;
    block *first_impossible_block;
    void *root_obj;
    std::atomic<block *> first_unallocated_block;
    free_list free_lists[60];

    static in_heap_header *load(const std::string &name);
    void sync();
    static in_heap_header *place_at(void *addr, size_t size);
  private:
    explicit in_heap_header(void *addr)
    : loaded_at(addr), size(0),
      first_block_in_mem(nullptr), first_impossible_block(nullptr),
      root_obj(nullptr), first_unallocated_block{nullptr}
    {}
  };

  inline bool in_heap_header::set_root(void *new_root, barrier &_barrier) {
    mutate_region r(_barrier);
    if (new_root != nullptr) {
      block *b = static_cast<block *>(new_root)-1;
      if (b < first_block_in_mem) {
        return false;
      }
      if (b >= first_unallocated_block) {
        return false;
      }
      if (b->_freep) {
        return false;
      }
    }
    root_obj = new_root;
    return true;
  }

}



#endif /* PHEAP_IMPL_H_ */
