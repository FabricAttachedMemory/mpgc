/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * gc_impl.cpp
 *
 *  Created on: Apr 15, 2015
 *      Author: Evan
 */

#include "mpgc/gc.h"
#include "mpgc/gc_vector.h"

using namespace mpgc;
using namespace std;

namespace {
  struct test : gc_allocated {
    gc_ptr<test> _next = nullptr;
    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(test)
	.WITH_FIELD(&test::_next);
      return d;
    }

    test(gc_token &gc)
    : gc_allocated{gc}
    {}
    test(gc_token &gc, const gc_ptr<test> &n)
    : gc_allocated{gc}, _next{n}
    {}
    test(gc_token &gc, gc_ptr<test> &&n)
    : gc_allocated{gc}, _next{n}
    {}
    test(gc_token &gc, const test &other)
    : gc_allocated{gc}, _next{other._next}
    {}
    test(gc_token &gc, test &&other)
    : gc_allocated{gc}, _next{other._next}
    {}

    static void process(const gc_ptr<const test> &);
    void test_process() {
      static_assert(std::is_assignable<int&, int>::value, "Assignable");
      process(GC_THIS);
      gc_ptr<test> t = make_gc<test>();
      process(t);
      process(make_gc<test>(t));
      make_gc_array<test>(5);
      gc_vector<int> v1(5, 10);
      gc_vector<test> v2;
      v1.emplace(v1.cbegin(), 10);
      v2.emplace(v2.cbegin(), t);
    }
 
  };

  struct test2 : gc_allocated_with_virtuals<test2> {
    struct virtuals : virtuals_base {
      virtual int v1(test2 *self, int a) = 0;
      virtual int v1c(const test2 *self, int a) const = 0;
    };

    int v1(int a) {
      return call_virtual(this, &virtuals::v1, a);
    }
    int v1c(int a) const {
      return call_virtual(this, &virtuals::v1c, a);
    }
  };

  struct test3 : test2 {
    struct virtuals : test2::virtuals {
      using impl = test3;
      int v1(test2 *self, int a) override {
	return self->call_non_virtual(&impl::v1_impl, a);
      }
      int v1c(const test2 *self, int a) const override {
	return self->call_non_virtual(&impl::v1c_impl, a);
      }
      virtual void v2(test3 *self) = 0;
    };
    int v1_impl(int a) {
      return a+1;
    }
    int v1c_impl(int a) const {
      return a+1;
    }
    void v2() {
      return call_virtual(this, &virtuals::v2);
    }
  };

  struct test4 : test3 {
    struct virtuals : test3::virtuals {
      using impl = test4;
      int v1(test2 *self, int a) override {
	return self->call_non_virtual(&impl::v1_impl, a);
      }
      void v2(test3 *self) override {
	self->call_non_virtual(&impl::v2_impl);
      }
    };
    int v1_impl(int a) {
      return a+1;
    }
    void v2_impl() {
    }
  };

  template <typename T>
  bool foo(const T&) {
    return false;
  }

  template <typename T, typename U>
  bool foo(const T&, const U&) {
    return false;
  }

  struct bar {
    bool operator()() const {
      return false;
    }
  };

}
