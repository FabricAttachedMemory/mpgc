#!/usr/bin/env python3
##
#
#  Multi Process Garbage Collector
#  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  As an exception, the copyright holders of this Library grant you permission
#  to (i) compile an Application with the Library, and (ii) distribute the 
#  Application containing code generated by the Library and added to the 
#  Application during this compilation process under terms of your choice, 
#  provided you also meet the terms and conditions of the Application license.
#


#
# missrate.py
#
#  Created on: August 1, 2016
#      Author: uversky
#
import argparse
import re
import subprocess
import sys

# Pass the same args as you would pass to rungcdemo.py

# Argument parsing boilerplate
def parse_args(arg_v=None):
    class Arg:
        def __init__(self, flag, help_str, dest, argtype=None, action='store', default=None):
            self.flag = flag
            self.help = help_str
            self.dest = dest
            self.type = argtype
            self.action = action
            self.default = default

    parser_desc_ = 'Run the social network application that demonstrates MPGC.'
    args = [
        Arg('-b', 'Runs the application in benchmark mode.',
            'benchmark', action='store_true'),
        Arg('-d', 'Prints additional debug info (memstats(), during execution.',
            'debug', action='store_true'),
        Arg('-f', 'Removes any existing graph under the same name in the persistent heap without a prompt.',
            'forceClear', action='store_true'),
        Arg('-i', 'Specifies the number of iterations of posts/comments to run across all worker threads.',
            'iters', argtype=int, default=10000),
        Arg('-k', 'Runs `pkill -9 -x gcdemo` to kill any running worker processes.',
            'kill', action='store_true'),
        Arg('-l', 'Specifies the maximum length of the user\'s feed.',
            'feedLength', argtype=int, default=200),
        Arg('-m', 'Specifies the target miss rate for binary searching.',
            'missRate', argtype=float, default=0.05),
        Arg('-mc', 'Sets the mean number of new users tagged in a post when commenting.',
            'meanNumCommentTags', argtype=float, default=1.0),
        Arg('-mf', 'Specifies the mean number of friends per user (drawn from an exponential distribution).',
            'meanNumFriends', argtype=int, default=200),
        Arg('-mp', 'Sets the mean number of friends tagged in a new post.',
            'meanNumPostTags', argtype=float, default=3.0),
        Arg('-n', 'Sets the name of the graph in the persistent heap.',
            'name', argtype=str, default='com.hpe.gcdemo.users'),
        Arg('-p', 'Sets the number of worker processes to spawn.',
            'numProcesses', argtype=int, default=1),
        Arg('-pc', 'Sets the proportion between posts and comments.  1 is all posts, 0 is all comments.',
            'postCommentProportion', argtype=float, default=0.6),
        Arg('-s', 'Skips graph initialization process (persistent counters are still cleared).',
            'skipInit', action='store_true'),
        Arg('-t', 'Sets the number of worker threads per process to NUM_THREADS.',
            'numThreads', argtype=int, default=1),
        Arg('-u', 'Sets the number of users used when generating the graph.',
            'users', argtype=int, default=1000000),
        Arg('-w', 'Specifies the ideal work rate (# iterations/sec) for the worker processes.',
            'idealWorkRate', argtype=int, default=100)
    ]

    parser = argparse.ArgumentParser(description=parser_desc_, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    for a in args:
        if a.action == 'store_true':
            parser.add_argument(a.flag, help=a.help, action=a.action, dest=a.dest)
        else:
            parser.add_argument(a.flag, help=a.help, type=a.type, default=a.default, dest=a.dest)
    return parser, parser.parse_args(arg_v)

def main():
    parser, parseArgs = parse_args(sys.argv[1:])
    args = ["./rungcdemo.py"]   # List of args for the benchmark script
    for i in range(1, len(sys.argv)):
        # Omit the miss rate argument and the ideal work rate argument
        #   (Miss rate argument is not valid for this script, and ideal work rate
        #    argument is worked out by the binary search)
        if sys.argv[i-1] == '-m' or sys.argv[i] == '-m' or \
                sys.argv[i-1] == '-w' or sys.argv[i] == '-w':
            continue
        args.append(sys.argv[i])
    
    thresh = 0.01               # Target miss rate +- 1%
    start_low  = 1
    start_high = 400000
    (low, high) = (start_low, start_high)    # Guess for iter count limits (TODO: arbitrary?)
    mid = (high+low) // 2
    args.append('-w')
    args.append(str(mid))

    bounds = (parseArgs.missRate - thresh, parseArgs.missRate + thresh)
    print("Binary searching to find the ideal work rate that leads to a miss rate of",
            parseArgs.missRate, "+-", thresh, ".")

    iters = 5;
    print("(Running rungcdemo.py", iters , "times for each specified -w rate.)")
    while mid > start_low and mid < start_high:
        missRates = []
        print("Trying -w", mid)

        # Take iters samples
        print("  Run #: ", end="")
        for i in range(iters):
            print(i+1, end="")
            sys.stdout.flush()
            # First copy the file.
            subprocess.call("cp /data/gidra/heaps/gc_heap heaps/", shell=True)
            subprocess.check_output("/home/gidra/code/vmtouch-master/bin/vmtouch -t heaps/gc_heap", shell=True)
            subprocess.call("cp /data/gidra/heaps/managed_heap heaps/", shell=True)
            print("...", end="")
            sys.stdout.flush()

            s = subprocess.check_output(args, universal_newlines=True)
            output_lines = s.split('\n')
            output_lines.pop()  # remove last \n from output
            missRates.append(float(output_lines[-1]))
            print(float(output_lines[-1]), " ", end="")
            #print(output_lines[-4:])
        
        print()
        missRates.sort()
        print("  Sampled rates: ", missRates)

        # Drop the extremes and average
        missRates.pop(0)
        missRates.pop()
        newMissRate = sum(missRates) / len(missRates)
        print("  Miss rate:", newMissRate)

        if newMissRate >= bounds[0] and newMissRate <= bounds[1]:
            print("  Optimum value found:", mid)
            sys.exit(0)
        elif newMissRate < bounds[0]:
            # We can go faster
            print("  -w too low, increasing rate")
            low = mid+1
        elif newMissRate > bounds[1]:
            # We need to slow down
            print("  -w too high, reducing rate")
            high = mid-1

        mid = (low+high) // 2
        args[-1] = str(mid)

    sys.exit(0)

if __name__ == '__main__':
    main()

