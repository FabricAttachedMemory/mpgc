/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


/*
 * Graph.h
 *
 *  Created on: June 1, 2016
 *      Author: uversky
 */

#ifndef GCDEMO_GRAPH_H_
#define GCDEMO_GRAPH_H_

#include "mpgc/gc.h"
#include "mpgc/gc_string.h"
#include "mpgc/gc_vector.h"
#include <algorithm>
#include <atomic>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;
using namespace mpgc;

class User;
class Post;
class Comment;

class User : public gc_allocated {
private:
  static atomic<unsigned long>& nextId() {
    static atomic<unsigned long> _nextId(0);
    return _nextId;
  }

public:
  unsigned long id,
                feedLength;
  atomic<unsigned long> numTags; // number of times tagged in posts, even ones that fell off
  gc_string name;
  atomic<gc_array_ptr<gc_ptr<Post>>> feed;
  gc_vector<gc_ptr<User>>            friends;

  User(gc_token &gc, unsigned long fl = 200, string nm = "John Doe")
    : gc_allocated{gc},
      id{nextId().fetch_add(1)},
      feedLength(fl),
      numTags(0),
      name(nm),
      feed{make_gc_array<gc_ptr<Post>>(0)},
      friends{gc_vector<gc_ptr<User>>()} {}

  static const auto &descriptor() {
    static gc_descriptor d = 
      GC_DESC(User)
      .WITH_FIELD(&User::id)
      .WITH_FIELD(&User::feedLength)
      .WITH_FIELD(&User::numTags)
      .WITH_FIELD(&User::name)
      .WITH_FIELD(&User::feed)
      .WITH_FIELD(&User::friends);
    return d;
  }

  bool isFeedFull() const {
    return feed.load()->size() == feedLength;
  }

  bool isFeedEmpty() const {
    return feed.load()->size() != 0;
  }

  size_t pushToFeed(gc_ptr<Post> p) {
    bool cas = false;
    size_t count = 0;
    while (!cas) {
      gc_array_ptr<gc_ptr<Post>> localFeed = feed;
      bool isEmpty = localFeed.size() == 0;
      bool isFull  = localFeed.size() >= feedLength;
      auto newFeed = make_gc_array<gc_ptr<Post>>(min(localFeed.size() + 1, feedLength));
      if (!isEmpty) {
        copy(localFeed.begin() + (isFull ? 1 : 0),  // drop earliest post if full
             localFeed.end(),
             newFeed.begin());
      }
      newFeed->back() = p;
      cas = feed.compare_exchange_strong(localFeed, newFeed);
      count++;
    }
    return count;
  }

  size_t bumpInFeed(gc_ptr<Post> p) {
    bool cas = false;
    size_t count = 0;
    while (!cas) {
      gc_array_ptr<gc_ptr<Post>> localFeed = feed;
      // If the post is the feed; bump it; otherwise add a new post.
      auto i = find(localFeed.begin(), localFeed.end(), p);
      bool isPostFound = i != localFeed.end();
      gc_array_ptr<gc_ptr<Post>> newFeed;

      if (isPostFound) {
        // Bump an existing post
        newFeed = make_gc_array<gc_ptr<Post>>(localFeed.size());
        auto it = copy(localFeed.begin(), i, newFeed.begin());  // [begin, i)
        copy(i+1, localFeed.end(), it); // Skip the post
        newFeed->back() = p;  // Add it back in at the end
      }
      else {
        // Add a new post
        bool isEmpty = localFeed.size() == 0;
        bool isFull  = localFeed.size() >= feedLength;
        newFeed = make_gc_array<gc_ptr<Post>>(min(localFeed.size() + 1, feedLength));
        if (!isEmpty) {
          copy(localFeed.begin() + (isFull ? 1 : 0),  // drop earliest post if full
               localFeed.end(),
               newFeed.begin());
        }
        newFeed->back() = p;
      }
      count++;
      cas = feed.compare_exchange_strong(localFeed, newFeed);
    }
    return count;
  }
};

class Post : public gc_allocated {
public:
  gc_string postText;
  atomic<gc_array_ptr<gc_ptr<User>>>    tagged;
  atomic<gc_array_ptr<gc_ptr<Comment>>> comments;

  Post(gc_token &gc, string pp = "i am a default post")
    : gc_allocated{gc},
      postText(pp),
      tagged{make_gc_array<gc_ptr<User>>(0)},
      comments{make_gc_array<gc_ptr<Comment>>(0)}
  {}

  Post(gc_token &gc, string pp, const unordered_set<gc_ptr<User>> &tags)
    : gc_allocated{gc},
      postText(pp),
      tagged{make_gc_array<gc_ptr<User>>(tags.begin(), tags.end())},
      comments{make_gc_array<gc_ptr<Comment>>(0)}
  {}

  static const auto &descriptor() {
    static gc_descriptor d = 
      GC_DESC(Post)
      .WITH_FIELD(&Post::postText)
      .WITH_FIELD(&Post::tagged)
      .WITH_FIELD(&Post::comments);
    return d;
  }

  void addTag(gc_ptr<User> u)
  {
    bool cas = false;
    while (!cas) {
      gc_array_ptr<gc_ptr<User>> localTagged = tagged;
      unordered_set<gc_ptr<User>> s;
      s.reserve(localTagged.size() + 1);
      s.insert(localTagged.begin(), localTagged.end());
      s.insert(u);
      auto newTagged = make_gc_array<gc_ptr<User>>(s.begin(), s.end());
      cas = tagged.compare_exchange_strong(localTagged, newTagged);
    }
    u->numTags++;
  }

  size_t addTags(const unordered_set<gc_ptr<User>> &newTags)
  {
    bool cas = false;
    size_t count = 0;
    while (!cas) {
      gc_array_ptr<gc_ptr<User>> localTagged = tagged;
      unordered_set<gc_ptr<User>> s(newTags);
      s.insert(localTagged.begin(), localTagged.end());

      auto newTagged = make_gc_array<gc_ptr<User>>(s.begin(), s.end());
      cas = tagged.compare_exchange_strong(localTagged, newTagged);
      count++;
    }

    for (auto u : newTags) {
      u->numTags++;
    }
    return count;
  }

  size_t addComment(gc_ptr<Comment> c)
  {
    bool cas = false;
    size_t count = 0;
    while (!cas) {
      gc_array_ptr<gc_ptr<Comment>> localComments = comments;
      auto newComments = make_gc_array<gc_ptr<Comment>>(localComments.size() + 1);
      copy(localComments.begin(), localComments.end(), newComments.begin());
      newComments->back() = c;
      cas = comments.compare_exchange_strong(localComments, newComments);
      count++;
    }
    return count;
    //  Dropping the pointer to the old array on the floor and letting the
    //  garbage collector worry about the cleanup.
  }
};

class Comment : public gc_allocated {
public:
  gc_ptr<Post> parent;
  gc_string    commentText;

  Comment(gc_token &gc, gc_ptr<Post> pp = nullptr, string cc = "i am a comment on a post")
    : gc_allocated{gc}, parent(pp), commentText(cc) {}

  static const auto &descriptor() {
    static gc_descriptor d = 
      GC_DESC(Comment)
      .WITH_FIELD(&Comment::parent)
      .WITH_FIELD(&Comment::commentText);
    return d;
  }
};

#endif /* GCDEMO_GRAPH_H */
